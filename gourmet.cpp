/*
Гурман

Нитуширг в жизни больше всего любит две вещи - вкусно поесть и отдыхать на море. Поэтому он решил совместить приятное с приятным и поехать на пятизвёздочный морской курорт Фокьнит. Но вот незадача: в Фокьните есть только одна столовая, меню в которой каждый день заранее фиксировано. Поскольку Нитуширг - гурман, он предпочитает разнообразие в еде, поэтому если за время отдыха какое-то меню попадётся более K раз - Нитуширг очень расстроится и весь отпуск пойдёт насмарку. При этом, разумеется, Нитуширг хочет отдохнуть на море как можно дольше. Ваша задача состоит в том, чтобы по известному заранее меню столовой на N дней выбрать как можно более длинный отрезок подряд идущих дней, в которые Нитуширг поедет в Фокьнит так, чтобы никакой набор блюд не повторялся более K раз за всё время поездки.
Формат входных данных
В первой строке вам даны целые числа 1 <= N <= 100000 и 1 <= K <= N - количество дней, когда Фокьнит открыт для гостей и K - максимальное количество раз, которое может повториться меню за время отпуска. В следующей строке входного файла вам дана строка, состоящая из N строчных латинских букв. Каждая буква означает свой вариант меню, разным меню соответствуют разные буквы.
Формат выходных данных
На выход ваша программа должна вывести два целых числа: 1 <= L <= N - максимальное количество дней отпуска Нитуширга и 1 <= d0 <= N - номер дня заезда. Считайте, что в день заезда Нитуширг успевает съесть предлагаемое столовой меню.

Примеры
1 1
a

1 1


6 2
abbbaa

4 3

*/

#include <iostream>

int main() {
	int N, K;
	std::cin >> N >> K;
	getchar();
	char lastChar = ' ';
	int repeatedTimes = 1,	// количество повторов в текущей последовательности
		times = 0,			// длина текущей последовательности
		maxTimes=0,			// длина максимальной последовательности
		dayOfStart = 0,		// индекс дня начала последовательности
		maxDayOfStart=0;	// индекс дня начала максимальной последовательности
	for (int i = 0; i < N; i++) {
		char c = getchar();
		if (c!=lastChar) {
			repeatedTimes = 1;
		}
		else if (++repeatedTimes > K) { // Превышено количество повторов
			if (maxTimes < times) {
				maxTimes = times;
				maxDayOfStart = dayOfStart;
			}
			times = K - 1;
			repeatedTimes = K;
			dayOfStart = i - K + 1;
		}

		times++;

		lastChar = c;
	}
	if (maxTimes < times) {
		maxTimes = times;
		maxDayOfStart = dayOfStart;
	}

	std::cout << maxTimes << ' ' << (maxDayOfStart+1);

}