/*
Сеть пунктов проката горнолыжного оборудования представляет собой корневое дерево, состоящее из n вершин, пронумерованных от 1 до n с корнем в вершине номер 1. В каждой вершине имеется пункт проката. Пункт, расположенный в i-й вершине, закупает оборудование по цене c_i рублей за комплект.

Пусть a_i - суммарное количество комплектов горнолыжного оборудования, которое будет закуплено во всех пунктах проката, находящихся в поддереве вершины номер i. Согласно маркетинговым исследованиям для каждого i эта величина должна находиться в диапазоне: l_i <= a_i <= r_i.

Необходимо определить, какое количество комплектов нужно закупить к началу сезона каждому из пунктов проката, чтобы для поддерева любой вершины сети общее количество комплектов находилось в указанном маркетологами диапазоне, а суммарная стоимость всех купленных комплектов была как можно меньше. Либо определить, что выполнить все условия маркетологов невозможно.

Напомним, что граф называется деревом, если он связный и не содержит циклов. Между любыми двумя вершинами в дереве существует ровно один простой путь. Корневым деревом называется дерево, в котором есть одна выделенная вершина - корень. Поддеревом вершины v называют множество всех вершин, для которых вершина v лежит на пути от соответствующей вершины до корня. Обратите внимание, что сама вершина v тоже входит в это множество. Родителем вершины v называется такая вершина p_v, что v и pv соединены ребром, и pv лежит на пути от v до корня.


Формат входных данных

Каждый тест состоит из нескольких наборов входных данных. В первой строке дано одно целое число t - количество наборов входных данных. Далее следует описание наборов входных данных.

В первой строке каждого набора входных данных дано одно целое число n (1 <= n <= 100000) - количество вершин в дереве.

Во второй строке даны n - 1 целых чисел p2, p3, ..., pn (1<= pi < i), обозначающих, что родителем вершины i является вершина pi.

В следующей строке даны n целых чисел c1, ..., cn (1 <= ci <= 10^9), где ci - цена закупки одного комплекта оборудования пунктом проката номер i.

В следующих n строках даны по два целых числа li и ri (0 <= li <= ri <= 10^9) - ограничения на общее количество комплектов горнолыжного оборудования в пунктах проката, находящихся в поддереве вершины номер i, к началу сезона.

Гарантируется, что сумма n по всем наборам входных данных не превышает 100000.


Формат выходных данных

Для каждого набора данных выведите ответ в следующем формате.

Если невозможно выполнить все условия маркетологов, в единственной строке выведите -1.

Иначе, в первой строке выведите минимальное количество рублей, которое необходимо потратить на закупку горнолыжного оборудования всем пунктам сети суммарно. Во второй строке выведите n целых чисел bi, где bi равно количеству комплектов, которое необходимо закупить пункту проката номер i. Если существует несколько способов выполнить все условия маркетологов, потратив минимальное возможное количество рублей, вы можете вывести любой из них.


Примеры

2
3
1 1
3 1 2
5 7
1 2
2 4
2
1
5 5
0 1
2 2

8
0 2 3
-1

==

1
10
1 2 1 1 4 2 1 2 5
229935705 252294888 574618756 226876866 225916692 249797075 133791770 102539705 760471176 956697279
125 237
48 102
13 27
20 42
29 58
11 22
21 41
13 26
7 15
20 40

45429982917
0 0 13 9 9 11 30 26 7 20 
*/

#include <vector>
#include <set>
#include <iostream>
#include <fstream>

using namespace std;

struct node;
// Comparator для сортировки cheaperOffsprings по возрастанию
struct compareCosts {
	bool operator()(const node* a, const node* b) const;
};

struct node {
	long long cost = 0;
	long long l = 0;
	long long r = 0;
	long long purchased = 0;
	long long a = 0;
	node* parent = nullptr;
	vector<node*> children;
	// Множество из потомков (дети, внуки и т.д.) с меньшей стоимостью покупки.
	// Автоматически упорядочен
	set<node*, compareCosts> cheaperOffsprings;
};

bool compareCosts::operator()(const node* a, const node* b) const {
	return a->cost < b->cost;
}

// Проходим по дереву и добавляем в родителей, прарадителей и т.д. себя, если у нас стоимость меньше, чем у них.
void fillOffsprings(node* root) {
	node* parent = root;
	while ((parent = parent->parent) != nullptr) {
		if (root->cost < parent->cost)
			parent->cheaperOffsprings.insert(root);
	}

	for (node* child : root->children) {
		fillOffsprings(child);
	}
}

constexpr void updateCountsToTheRoot(node* current, long long count) {
	// Увеличиваем счётчик child->a у child и всех предков включая current
	do {
		current->a += count;
	} while ((current = current->parent) != nullptr);
}

// Функция возвращает сколько можно закупить на потомке child, чтобы нигде на промежуточных
// звеньях не выйти за дозволенные границы
// Она требуется чтобы если внук может купить 100, а сын (отец внука) максимум только 50
// При этом деду нужно 150, т.е. он может принять все 100. При такой ситуации внук может купить только 50.
long long getCanBuy(node* child, node* parent) {
	long long canbuy = child->r - child->a;
	while ((child = child->parent) != parent) {
		canbuy = min(canbuy, child->r - child->a);
	}
	return canbuy;
}

long long solvenew(node* root) {
	// Обход в ширину, чтобы идти от корня вниз по уровням
	vector<node*> queue;
	queue.push_back(root);

	// Последовательно рекурсивно добавляем всех детей
	for (int i = 0; i < queue.size(); i++) {
		queue.insert(queue.end(), queue[i]->children.begin(), queue[i]->children.end());
	}

	// Для задачи нужно идти по дереву в обратном порядке: сначала листья, затем второй уровень с конца и т.д.
	long long sum = 0;
	for (int i = ((int) queue.size()) - 1; i >= 0; i--) {
		node* current = queue[i];

		if (current->a > current->r)
			return -1;

		// Ищем среди более выгодных точек покупки потомков
		long long needbuy = current->l - current->a;

		if (needbuy <= 0)
			continue;

		for (node* offspring : current->cheaperOffsprings) {
			long long canbuy = getCanBuy(offspring, current);
			if (canbuy == 0) continue;

			long long tobuy = min(needbuy, canbuy);
			sum += tobuy * offspring->cost;
			offspring->purchased += tobuy;

			// Увеличиваем счётчик child->a и у всех предков до корня
			updateCountsToTheRoot(offspring, tobuy);

			// Обновляем требуемое для закупки количество
			needbuy = current->l - current->a;
		}

		// Если среди потомков с низкими ценами не набралось достаточно, то покупаем из собственного кармана
		if (needbuy > 0) {
			sum += needbuy * current->cost;
			current->purchased = needbuy;
			updateCountsToTheRoot(current, needbuy);
		}
	}

	return sum;
}

int main()
{
	fstream fs("tests/10");
	int t = 0;
	fs >> t;
	for (int i = 0; i < t; i++) {
		long long n = 0;
		fs >> n;

		vector<node> tree(n);
		
		for (int j = 1; j < n; j++) {
			uint64_t temp;
			fs >> temp;
			tree[temp - 1].children.push_back(&tree[j]);
			tree[j].parent = &tree[temp - 1];
		}

		for (int j = 0; j < n; j++) {
			fs >> tree[j].cost;
		}

		for (int j = 0; j < n; j++) {
			fs >> tree[j].l >> tree[j].r;
		}

		// Заполняем информацию о дешёвых потомках
		fillOffsprings(&tree[0]);

		long long sum = solvenew(&tree[0]);
		cout << sum << endl;
		if (sum != -1) {
			for (node& a : tree) {
				cout << a.purchased << " ";
			}
			cout << endl;
		}
	}
}
