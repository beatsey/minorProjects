# minorProjects
В данном репозитории собраны небольшие программы в том числе на динамическое программирование и жадные алгоритмы.

---

### Задача о рюкзаке (backpack.cpp)
Решить задачу о рюкзаке методом динамического программирования. Алгоритм должен быть инкапсулирован.

#### Формат входных данных
Данные подаются на стандартный поток ввода. Пустые строки игнорируются.
Первая строка содержит натуральное число - максимальную массу предметов, которую выдержит рюкзак.
Каждая последующая содержит два неотрицательных числа: массу предмета и его стоимость.

#### Формат результата
Первая строка содержит два числа: суммарную массу предметов и их суммарную стоимость.
В последующих строках записаны номера предметов, которые были помещены в рюкзак, в порядке возрастания номера.
Результат работы программы выводится в стандартный поток вывода.
В любой непонятной ситуации результатом работы любой команды будет "error".

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
165<br>
23 92<br>
31 57<br>
29 49<br>
44 68<br>
53 60<br>
38 43<br>
63 67<br>
85 84<br>
89 87<br>
82 72
</td>
  <td valign='top'>
165 309<br>
1<br>
2<br>
3<br>
4<br>
6
</td>
  </tr>
</tbody></table>

---

### Сумасшедший богач (millionaire_dynamic.py, millionaire_fastest.py)
Один сумасшедший богач на старости лет впал в маразм и стал еще более сумасшедшим. Он решил отдать половину своих богатств тому, кто выиграет в математической игре.
Правила игры: изначально каждый игрок начинает с нулевой суммой. Он может либо получить у богача 1 миллион сантиков, либо отдать ему 1 миллион сантиков, либо получить от богача ту же сумму, которая есть у него сейчас.
Выигрывает тот, кто за минимальное количество действий наберет сумму, равную половине состояния богача.
На беду других игроков, нашелся человек, который что-то слышал про жадные алгоритмы и двоичную систему счисления (возможно это вы).

#### Формат входных данных
В стандартном потоке записано единственное натуральное число - размер половины состояния богача (в миллионах).

#### Формат результата
Каждая строка выхода содержит ровно одну операцию (inc, dec или dbl) из кратчайшей последовательности действий для победы.
Результат работы программы выводится в стандартный поток вывода.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign="top">23</td>
    <td valign="top">
inc<br>
dbl<br>
inc<br>
dbl<br>
dbl<br>
dbl<br>
dec
</td>
  </tr>
</tbody></table>

---

### Автокоррекция (word_correction.py)
Реализуйте программу, которая предлагает варианты замены слова, в котором допущена одна ошибка.
Эту задачу можно решить достаточно многими способами - на это ограничений нет, но код должен быть хорошего качества и читаемым.
Регистр букв для программы коррекции не имеет значения (слова в словаре хранятся в нижнем регистре).
Варианты ошибок - как в алгоритме Дамерау-Левенштейна: вставка лишнего символа, удаление символа, замена символа или транспозиция соседних символов.

#### Формат входных данных
Данные подаются на стандартный поток ввода. Пустые строки игнорируются.
Первая строка содержит число N - количество слов в словаре.
Последующие N строк содержат слова из словаря, по одному в строке.
Остальные строки - слова, которые надо проверять.

#### Формат результата
Каждая строка выхода содержит предложение для исправления слов, в порядке их появления.
Если слово не содержит ошибок, то выводится "%слово% - ok".
Если слово содержит одну ошибку, то выводится "%слово% -> %слово_в_словаре%". Если вариантов несколько, то они разделяются запятой с пробелом.
Если слово содержит более одной ошибки, то выводится "%слово% -?"
Результат работы программы выводится в стандартный поток вывода.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign="top">
8<br>
some<br>
random<br>
words<br>
for<br>
testing<br>
your<br>
solutions<br>
far<br>
<br>
some<br>
randoms<br>
wards<br>
seeking<br>
fro<br>
solution<br>
fur
</td>
    <td valign="top">
some - ok<br>
randoms -&gt; random<br>
wards -&gt; words<br>
seeking -?<br>
fro -&gt; for<br>
solution -&gt; solutions<br>
fur -&gt; far, for
</td>
  </tr>
</tbody></table>


---

### Разложение на слагаемые (decompose.cpp)
Дано натуральное число N. Рассмотрим его разбиение на различные натуральные слагаемые. Два разбиения, отличающихся только порядком слагаемых, будем считать за одно, поэтому можно считать, что слагаемые в разбиении упорядочены по невозрастанию.

#### Формат входных данных
Задано единственное число N. (N ≤ 40)

#### Формат результата
Необходимо вывести все разбиения числа N на различные натуральные слагаемые в обратном лексикографическом порядке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign="top">5</td>
    <td valign="top">
5<br>
4 1<br>
3 2<br>
3 1 1<br>
2 2 1<br>
2 1 1 1<br>
1 1 1 1 1
</td>
  </tr>
</tbody></table>

---

### Максимальный палиндром (maxpalindrome.py)
Палиндром - это строка, которая читается одинаково как справа налево, так и слева направо.

На вход программы поступает набор больших латинских букв (не обязательно различных). Разрешается переставлять буквы, а также удалять некоторые буквы. Требуется из данных букв по указанным правилам составить палиндром наибольшей длины, а если таких палиндромов несколько, то выбрать первый из них в алфавитном порядке.

#### Формат входных данных
В первой строке входных данных содержится число N (1 <= N <= 100000). Во второй строке задается последовательность из N больших латинских букв (буквы записаны без пробелов).

#### Формат результата
В единственной строке выходных данных выдайте искомый палиндром.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign="top">
3<br>
AAB</td>
    <td valign="top">ABA</td>
  </tr>
  <tr>
    <td valign="top">
6<br>
QAZQAZ</td>
    <td valign="top">AQZZQA</td>
  </tr>
  <tr>
    <td valign="top">
6<br>
ABCDEF</td>
    <td valign="top">A</td>
  </tr>
</tbody></table>

---

### Сортировка матрицы (matrixSort.cpp)
Напишите алгоритм сортировки двумерного массива n на n такой, что A[i][j] ≤ A[k][m], если i+j < k+m.
Внутри антидиагонали упорядоченность по возрастанию по строкам.
Постарайтесь использовать O(1) памяти.
Реализация алгоритма должна быть инкапсулирована.

#### Формат входных данных
Данные подаются на стандартный поток ввода.
Первая строка содержит число N - размерность массива.
Последующие N строк содержат N целых неотрицательных чисел, помещающихся в int32.

#### Формат результата
Вывод результирующей матрицы построчно через пробел.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign="top">
3<br>
1 3 2<br>
7 8 9<br>
6 8 9
</td>
    <td valign="top">
1 2 6<br>
3 7 8<br>
8 9 9
</td>
  </tr>
</tbody></table>

---

### Быстрая сортировка (quicksort.py)

Реализуйте эффективный алгоритм быстрой сортировки, который обсуждался на семинаре.

#### Формат входных данных
Ввод осуществляется со стандартного потока ввода.
Первая и единственная строка всегда содержит входной массив.
Все данные гарантированно валидны, проверять данные на корректность не нужно.

#### Формат результата
Результат работы - отсортированный массив.
Результат работы программы выводится в стандартный поток вывода.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>4 3 5 1 2</td>
    <td valign='top'>1 2 3 4 5</td>
  </tr>
</tbody></table>

---

### Бинарный поиск (binarysearch.py)
Реализуйте рекурсивно алгоритм бинарного поиска.
Реализация алгоритма должна быть инкапуслирована, т.е. не зависеть от форматов входных/выходных данных и непосредственно ввода/вывода.

#### Формат входных данных
Ввод осуществляется со стандартного потока ввода.
Первая строка всегда содержит отсортированный массив, в котором должен производится поиск.
Остальные строки имеют формат search K, где K - некоторое число.
Все данные гарантированно валидны, проверять данные на корректность не нужно.

#### Формат результата
Результат поиска - индекс числа в массиве. Если число в массиве отсутствует, то результатом будет -1.
Результат работы программы выводится в стандартный поток вывода.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
10 20 30 40 50 60 70 80<br>
search 30<br>
search 5
    </td>
    <td valign='top'>
2<br>
-1</td>
  </tr>
</tbody></table>

---

### Перестановки (permutations.py)
Реализуйте алгоритм генерации перестановок с началом в произвольной перестановке.
Реализация алгоритма должна быть инкапсулирована и не зависеть от ввода/вывода.

#### Формат входных данных
На стандартном потоке ввода в первой и единственной строке задаётся перестановка — несколько чисел, разделенных пробелами.

#### Формат результата
На стандартный поток вывода выводятся построчно все последующие перестановки, включая входную, в лексикографическом порядке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>3 2 1 4</td>
    <td valign='top'>
3 2 1 4<br>
3 2 4 1<br>
3 4 1 2<br>
3 4 2 1<br>
4 1 2 3<br>
4 1 3 2<br>
4 2 1 3<br>
4 2 3 1<br>
4 3 1 2<br>
4 3 2 1<br>
1 2 3 4<br>
1 2 4 3<br>
1 3 2 4<br>
1 3 4 2<br>
1 4 2 3<br>
1 4 3 2<br>
2 1 3 4<br>
2 1 4 3<br>
2 3 1 4<br>
2 3 4 1<br>
2 4 1 3<br>
2 4 3 1<br>
3 1 2 4<br>
3 1 4 2
    </td>
  </tr>
</tbody></table>

---

### Самый частый элемент массива (mostcommon.py)
Реализуйте алгоритм поиска наиболее частого элемента массива, который работает за линейное время.

#### Формат входных данных
Ввод осуществляется со стандартного потока ввода.
Первая и единственная строка всегда содержит входной массив.
Все данные гарантированно валидны, проверять данные на корректность не нужно.

#### Формат результата
Результат поиска - самый частый элемент массива. Если таких чисел несколько, то наименьшее из них.
Результат работы программы выводится в стандартный поток вывода.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>2 5 1 3 5 4 2 3 5 4 3 4 5 4 5</td>
    <td valign='top'>5</td>
  </tr>
</tbody></table>

---

### Сферы в параллелепипедах (spheresinside.py)
В трёхмерном пространстве описан набор сфер и прямоугольных параллелепипедов. Требуется определить, находятся ли все сферы внутри параллелепипедов или нет.

#### Формат входных данных
В первой строке через пробел записаны 2 целых числа M и K - количество сфер и параллелепипедов соответственно.
Оба числа не превышают 10. Далее идёт M строк по 4 числа в строке через пробел: целочисленные координаты X,Y,Z центров сфер (не превышают по модулю 1000) и целочисленный радиус (от 1 до 100). Далее - K строк, описывающих параллелепипеды, по 24 целых числа - координат вершин (не превышают по модулю 2000) в строке через пробел: X1 Y1 Z1 X2 Y2 Z2 X3 Y3 Z3 X4 Y4 Z4 X5 Y5 Z5 X6 Y6 Z6 X7 Y7 Z7 X8 Y8 Z8.

#### Формат результата
Номера сфер по порядку ввода (нумерация начинается с 1), которые не находятся полностью в параллелепипедах.

Параллелепипеды не могут быть вложены друг в друга, между собой не пересекаются и не соприкасаются.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
2 1<br>    
1 1 1 1<br>
10 10 10 2<br>
0 0 0 10 0 0 0 10 0 10 10 0 0 0 10 10 0 10 0 10 10 10 10 10
    </td>
    <td valign='top'>2</td>
  </tr>
</tbody></table>

---

### Последняя цифра (lastdigit.py)
Для заданного в некоторой системе счисления числа N определить последнюю цифру числа N^k.

#### Формат входных данных
В строке через пробел записаны число C - основание системы счисления от 2 до 20, целое число N (не более 5 разрядов, в C-й системе счисления) и положительная целая степень k в десятичной системе счисления, не превышающая 100.

#### Формат результата
Последняя цифра N^k в C-й системе счисления.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>2 111 3</td>
    <td valign='top'>1</td>
  </tr>
  <tr>
    <td valign='top'>16 AE 2</td>
    <td valign='top'>4</td>
  </tr>
</tbody></table>

---

### Минимальное число контейнеров (mincontainers.py)
Мама Малыша готовится к приёму гостей, ей срочно нужно приготовить очень много тефтелей. Готовые тефтели она решила раскладывать по кастрюлям и позвала Малыша помочь принести нужные кастрюли. Помогите Малышу определить минимальное количество кастрюль, которые потребуются.

#### Формат входных данных
В первой строке через пробел записаны целые числа N и M - минимальный общий объём кастрюль, который понадобится, и количество свободных кастрюль на кухне.
Далее M строк, в каждой записано по одному вещественному числу - объём соответствующей кастрюли.

#### Формат результата
Номера кастрюль, которые надо принести Малышу, записанные по одному в строке, в порядке возрастания. Номера считать по порядку входных данных, начиная с единицы.
Если подходит несколько возможных вариантов, то Малышу требуется принести самые большие кастрюли.
В случае, если подходящих кастрюль нет, вывести слово NO.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5 4<br>
1<br>
3.5<br>
2<br>
4
    </td>
    <td valign='top'>
2<br>
4
    </td>
  </tr>
  <tr>
    <td valign='top'>
3 5<br>
1<br>
0.8<br>
1.2<br>
2<br>
1.5
    </td>
    <td valign='top'>
4<br>
5
    </td>
  </tr>
</tbody></table>

---

### Мороженое и холодильник (refrigerator.java)
Харитон любит мороженое.
В своём любимом магазине мороженого Харитон каждому сорту мороженого присвоил рейтинг.
Чем больше этот рейтинг, тем вкуснее мороженое с точки зрения Харитона.
Каждый день в киоске некоторое мороженое назначаются мороженым дня и продают со скидкой.
Харитон любит экономить, поэтому он покупает только мороженое дня или не покупает мороженого вообще.
Если рейтинг мороженого дня не меньше, чем рейтинг самого вкусного мороженого, хранящегося в холодильнике Харитона, то он купит две порции этого мороженого.
Одну съест сразу, а вторую положит в холодильник.
Иначе Харитон не будет ничего покупать и съест самое вкусное мороженое из своего холодильника.

Требуется по заданной информации о мороженых дня за n дней определить, какое максимальное количество порций мороженого одновременно оказывалось в холодильнике Харитона на протяжении этих n дней.
А также какое мороженое Харитон покупал чаще всего.

#### Формат входных данных
В первой строке содержится целое число (1<=n<=300000) - количество дней, для которых имеется информация о мороженом.

В каждой из следующих n строк содержится информация о мороженом дня в соответствующий день: наименование сорта мороженного s_j и через пробел его рейтинг r_j (0<=r_j<=1000000).

Наименование сорта мороженого s_j - непустая строка из строчных латинских букв, цифр и нижнего подчёркивания, начинающаяся с буквы и имеющая длину не более 30 символов.

Гарантируется, что для фиксированного наименования мороженого рейтинг сорта мороженого постоянный.

#### Формат результата
В первой строке выведите целое число m - максимальное число одновременно лежавших в холодильнике порций мороженого.

Во второй строке вывести целые числа v и k - максимальное количество раз, которое Харитон покупал мороженое одного и того же сорта, и количество сортов мороженого, которые Харитон покупал чаще всего.

Далее выведите k строк, в каждой строке укажите по одному наименованию сорта мороженого, которое Харитон покупал чаще всего.
Наимеинования сортов выводите в лексикографическом (алфавитном) порядке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
14<br>
strawberry 3<br>
vanilla 5<br>
blackberry 4<br>
banana 3<br>
strawberry 3<br>
watermelon 2<br>
lemon 6<br>
vanilla 5<br>
blackberry 4<br>
vanilla2 4<br>
strawberry 3<br>
vanilla2 4<br>
vanilla 5<br>
strawberry 3
    </td>
    <td valign='top'>
5<br>
2 3<br>
strawberry<br>
vanilla<br>
vanilla2
	</td>
  </tr>
</tbody></table>


---

### Мороженое и холодильник 2 (refrigerator2.java)
Харитон решил изменить стратегию.
Он не станет покупать мороженое в двух случаях:
* Если в холодильнике имеется мороженое, которое лежит там уже d дней. В этом случае Харитон съест в этот день именно это мороженое.
* Если никакое мороженок не лежит в холодильнике d дней, но рейтинг мороженого дня меньше, чем рейтинг самого вкусного мороженого, которое есть у Харитона в холодильнике. В этом случае Харитон съест в этот день самое вкусное мороженое из своего холодильника. Если в холодильнике несколько порций мороженого с одинаковым рейтингом, то он съест то, которое купил последним.

Если рейтинг мороженого дня не меньше, чем рейтинг самого вкусного мороженого, хранящегося в холодильнике Харитона, и, кроме того, никакое мороженое в холодильнике не лежит уже d дней, Харитон купит две порции мороженого дня.
Одну съест, а вторую положит в холодильник.

Требуется по заданной информации о мороженых дня за n дней определить:
* Сколько раз Харитон отказывался от покупки мороженого, рейтинг которого был выше, чем хотя бы у одного мороженого, имевшегося в тот момент в холодильнике.
* Максимальное количество дней, которое порция мороженого провела в холодильнике Харитона, и количество таких порций.
* Количество сортов мороженого, порции которого пробыли в холодильнике максимальное количество дней, и вывести список этих сортов в лексикографическом (алфавитном) порядке.

#### Формат входных данных
В первой строке содержатся целые числа n,d
(1<=n<=300000, 1<=d<=100000) - количество дней, для которых имеется информация о мороженом дня, количество дней, в течение которого Харитон считает нахождение мороженого в холодильнике допустимым.

В каждой из следующих n строке содержится информация о мороженом дня в соответствующий день: наименование сорта мороженого s_j и через пробел его рейтинг r_j с точки зрения Харитона (j=1,2,...,n), (0<=r_j<=1000000)

Наименование сорта мороженого s_j - непустая строка из строчных латинских букв, цифр и нижнего подчёркивания, начинающаяся с буквы и имеющая длину не более 30 символов.

Гарантируется, что для фиксированного наименования мороженого рейтинг сорта мороженого постоянный.

#### Формат результата
В первой строке выведите целое число z - количество раз, которое Харитон отказывался от покупки мороженого, рейтинг которого был выше, чем хотя бы у одного мороженого, имевшегося в тот момент в холодильнике.

Во второй строке выведите целые числа p и q - максимальное количество дней, которое порция мороженого провела в холодильнике Харитона, и количество таких порций.

В третьей строке выведите целое число w - количество сортов, порции которых провели в холодильнике Харитона максимальное количество дней.

Далее выведите w строк - названия этих сортов в лексикографическом (алфавитном) порядке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
14 3<br>
strawberry 3<br>
vanilla 5<br>
blackberry 4<br>
banana 3<br>
strawberry 3<br>
watermelon 2<br>
lemon 6<br>
vanilla 5<br>
blackberry 4<br>
vanilla2 4<br>
strawberry 3<br>
vanilla2 4<br>
vanilla 5<br>
strawberry 3
    </td>
    <td valign='top'>
1<br>
3 2<br>
2<br>
blackberry<br>
strawberry
	</td>
  </tr>
  <tr>
    <td valign='top'>
8 4<br>
blackberry 4<br>
strawberry 3<br>
vanilla 5<br>
watermelon 2<br>
banana 3<br>
lemon 6<br>
strawberry 3<br>
vanilla 5
    </td>
    <td valign='top'>
0<br>
3 1<br>
1<br>
banana
	</td>
  </tr>
  <tr>
    <td valign='top'>
1 1<br>
blackberry 4
    </td>
    <td valign='top'>
0<br>
0 1<br>
1<br>
blackberry
	</td>
  </tr>
</tbody></table>


---

### Контрольная работа (controlwork.java)
Фалалель готовится к контрольной работе.

По просьбе Фалалеля его товарищ подобрал ему n задач, для каждой из которых указал уровень сложности d_j. По мнению товарища, Фалалей в начальный момент времени способен решать задачи с уровнем сложности, не превосходящим величину f. Для краткости будем говорить, что в начальный момент времени Фалалей обладает навыком f.

Фалалей решает задачи в порядке нумерации.

Возможны следующие исходы:
* Фалалей решает задачу и уровень сложности больше текущего навыка f. В этом случае Фалалель испытывает положительные эмоции, а его навык выростает до уровня сложности задачи.
* Фалалей решает задачу и уровень сложности не больше текущего навыка f. В этом случае Фалалелю становится скучно.
* Фалалей не решает задачу. В этом случае Фалалей испытывает отрицательные эмоции. Если при этом сложность задачи не больше навыка Фалалея, то его навык уменьшается на единицу.

Ваша задача - по представленным номерам задач определить:
* минимальный и максимальный уровни сложности задачи, которую Фалалей не решил к моменту, когда он завершил работу над задачей с представленным номером;
* каких эмоций Фалалей испытал больше к моменту, когда он завершил работу над задачей с заданным номером.

#### Формат входных данных
В первой строке содержатся целые числа n,m,f
(1<= n,m <= 100000, 1 <= f<=1000000) - количество задач в наборе, количество заданных номеров задач и начальный навык Фалалея соответственно.

Во второй строке содержится n целых чисел d_1, d_2, ..., d_n (1<=d_j<=1000000, j=1,2,...,n) - уровни сложности задач.

В третьей строке содержится последовательность из n символов (без пробелов) A и R. Если на i-й позиции находится символ A, то Фалалей решил соответствующую задачу. Если R, то не решил.

В четвёртой строке содержится m целых чисел p_1, p_2, ..., p_m - номера задач, для которых нужно ответить на вопрос задачи.

#### Формат результата
Выведите m строк.
Каждая строка должна содержать два целых числа и обозначение эмоции, которую Фалалей испытывал наиболее часто к этому моменту.
Числа и обозначение эмоции должны быть разделены пробелами.

Первое и второе числа - это минимальный и максимальный уровень сложности задачи, которую Фалалей не решил к моменту завершения работы над задачей с номером p_i.
Если к этому моменту Фалалель решил все предыдущие задачи, выведите -1.

Обозначение эмоции - это последовательность символов ":-)", ":-(" для положительных и отрицательных эмоций, ":-|" для скуки.

Если Фалалей к моменту завершения работы над задачей с номером p_i испытал одинаковое (максимальное) количество различных эмоций, следует выводить обозначение той эмоции, которую он испытал позже.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
15 10 8<br>
7 5 7 8 14 6 11 7 11 12 3 11 14 12 14<br>
ARRAAARAAARRAAA<br>
7 3 14 13 9 15 8 5 3 12
    </td>
    <td valign='top'>
5 11 :-(<br>
5 7 :-(<br>
3 11 :-)<br>
3 11 :-)<br>
5 11 :-)<br>
3 11 :-|<br>
5 11 :-|<br>
5 7 :-)<br>
5 7 :-(<br>
3 11 :-(
	</td>
  </tr>
  <tr>
    <td valign='top'>
3 4 5<br>
7 3 8<br>
AAA<br>
3 2 1 3
    </td>
    <td valign='top'>
-1 -1 :-)<br>
-1 -1 :-|<br>
-1 -1 :-)<br>
-1 -1 :-)
	</td>
  </tr>
</tbody></table>


---

### Подготовка (preparations.java)
Харитон расспросил однокурсников, уже сдавших экзамен, какие дополнительные вопросы задавал им преподаватель.

Всего Харитон расспросил n однокурсников, и каждый из них перечислил Харитону заданные ему дополнительные вопросы.
Для каждого дополнительного вопроса Харитон записывал тему, к которой этот вопрос относится.

Требуется выяснить, по каким темам было задано больше всего дополнительных вопросов.

#### Формат входных данных
В первой строке содержится целое число n (1<=n<=1000) - количество однокурсников, которых расспросил Харитон.

В каждой из следующих n строк содержится число m_i (0<=m_i<=1000) - количество дополнительных вопросов, на которые пришлось отвечать i-му однокурснику.
Через пробел далее записаны m_i чисел t_1,t_2,...,t_m_i (1<=t_i<=1000000) - номера тем, к которым относились эти вопросы.

#### Формат результата
В первой строке выведите целые числа p и q - количество тем, по которым было задано максимальное количество дополнительных вопросов, и количество этих вопросов.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
6<br>
3 10 5 14<br>
2 14 12<br>
5 8 13 5 12 3<br>
4 10 13 1 4<br>
0<br>
3 2 2 8
    </td>
    <td valign='top'>7 2</td>
  </tr>
</tbody></table>

---

### Регистрация (registration.py)
Предварительно создайте текстовый файл (accounts.txt), в котором структурирована информация вида: login -> password (не менее 5 пар). При этом на каждой строчке содержатся уникальные логины, а пароли могут повторяться. Создайте функцию регистрации нового пользователя, которая будет предлагать пользователю ввести логин и пароль до тех пор, пока не будет введён уникальный логин, и пароль не будет соответствовать требованиям:
* Наличие букв в разных регистрах
* Наличие цифры
* Наличие спецсимвола (@,!,$,#)

Корректная комбинация должна быть добавлена в текстовый файл accounts.txt.

Содержимое accounts.txt на начало работы:
```
login1 -> password
user -> friendly
summer -> qwerty
qbq812309 -> gdhjasdgj
nagibator228 -> systemCall1238sj
newUser -> Hey2201#
```

---

### Две кучи (two_heaps.cpp)
Имеется 2<=N<=23 камня с целочисленными весами W1, W2, ... , WN. Требуется разложить их на две кучи таким образом, чтобы разница в весе куч была минимальной. Каждый камень должен принадлежать ровно одной куче.

#### Формат входных данных
N<br>
W1 W2 ... WN

#### Формат результата
Минимальная неотрицательная разница в весе куч.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
8 9 6 9 8
    </td>
    <td valign='top'>4</td>
  </tr>
  <tr>
    <td valign='top'>
6<br>
14 2 12 9 9 8
    </td>
    <td valign='top'>2</td>
  </tr>
</tbody></table>

---

### Польский калькулятор (calculator_polsk_prefix.cpp)
Для вычисления арифметических выражений на практике удобно использовать польскую запись. В ней операции записывают перед операндами, а не между как мы привыкли. Таким образом<br>
\- 2 1 = (2 - 1)<br>
и<br>
\- * / 15 - 7 + 1 1 3 + 2 + 1 1 = 15 / (7 - (1 + 1)) * 3 - (2 + (1 + 1))

Вам необходимо написать калькулятор, который вычисляет значение арифметического выражения в префиксной записи. Размеры операндов и результаты операций не превосходят 1000.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>+ 1 2</td>
    <td valign='top'>3</td>
  </tr>
  <tr>
    <td valign='top'>- * / 15 - 7 + 1 1 3 + 2 + 1 1</td>
    <td valign='top'>5</td>
  </tr>
</tbody></table>

---

### Польский калькулятор (обратный) (calculator_polsk_reverse.py)
Задание связано с обратной польской нотацией. Она используется для парсинга арифметических выражений. Ещё её иногда называют постфиксной нотацией. В постфиксной нотации операнды расположены перед знаками операций.

#### Формат входных данных
В единственной строке дано выражение, записанное в обратной польской нотации. Числа и арифметические операции записаны через пробел.
На вход могут подаваться операции: +, -, *, / и числа, по модулю не превосходящие 10000.
Операция / является математическим целочисленным делением с округлением вниз.
Гарантируется, что значение промежуточных выражений в тестовых данных по модулю не больше 50000.

#### Формат результата
Выведите единственное число - значение выражения.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>3 4 +</td>
    <td valign='top'>7</td>
  </tr>
  <tr>
    <td valign='top'>12 5 /</td>
    <td valign='top'>2</td>
  </tr>
  <tr>
    <td valign='top'>-1 3 /</td>
    <td valign='top'>-1</td>
  </tr>
  <tr>
    <td valign='top'>10 2 4 * -</td>
    <td valign='top'>2</td>
  </tr>
  <tr>
    <td valign='top'>2 1 + 3 *</td>
    <td valign='top'>9</td>
  </tr>
  <tr>
    <td valign='top'>7 2 + 4 * 2 +</td>
    <td valign='top'>38</td>
  </tr>
</tbody></table>

---

### Торговый автомат (h11_authomata.cpp)
Одна фирма обслуживает автоматы по продаже чая и кофе. Стоимость стакана чая и кофе в автомате равна пяти рублям. Автомат принимает монеты по 5 и 10 рублей, а также купюры в 10, 50 и 100 рублей. Когда покупателю надо выдавать сдачу (т.е. когда пассажир бросил в автомат десятирублёвую монету или 10-, 50- или 100- рублёвую купюру), автомат выдаёт сдачу пятирублёвыми монетами; если же покупатель бросил в автомат пятирублёвую монету, то автомат её сохраняет и может использовать для сдачи следующим покупателям. Ясно, что, чтобы обеспечить возможность выдачи сдачи всем покупателям, может потребоваться изначально загрузить в автомат некоторое количество пятирублёвых монет.

Сейчас автоматы проходят испытания с целью определить минимальное количество монет, которые надо загрузить в автомат перед началом дня.Вам дан протокол одного из таких испытаний: известен порядок, в котором покупатели оплачивали свои покупки различными монетами и купюрами.Определите, какое минимальное количество пятирублёвых монет должно было изначально находиться в автомате, чтобы всем покупателям хватило сдачи.

#### Формат входных данных
В первой строке входных данных находится одно натуральное число N — количество покупок в автомате, которые были совершены в ходе испытания 1<=N<=50000.
Во второй строке находятся N натуральных чисел, каждое из которых равно номиналу монеты или купюры, которую использовал очередной покупатель для оплаты; каждый номинал может принимать одно из четырёх значений: 5, 10, 50 или 100.

#### Формат результата
Выведите одно число — минимальное количество пятирублёвых монет, которые надо было загрузить в автомат изначально, чтобы всем покупателям хватило сдачи.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
3<br>
10 5 100</td>
    <td valign='top'>19</td>
  </tr>
  <tr>
    <td valign='top'>
3<br>
5 5 10</td>
    <td valign='top'>0</td>
  </tr>
</tbody></table>

---

### Обратное число по модулю (h12_reciprocal.cpp)
Известно, что команда деления целых чисел на современных компьютерах исполняется неприлично долго. Оптимизирующие компиляторы во многих случаях заменяют операцию деления на константу группой операций, в которых имеется умножение на другую константу.

Для этого компилятору, в числе других действий, требуется найти такое число q для заданного делителя p, что q * p = 1 по известному модулю m.

Ваша задача по заданным числам 2 <= p,m <= 4 294 967 295 найти любое число q такое, чтобы (p * q) (mod m) = 1.

Известно также, что m — простое число, и что для заданных p и m ответ существует.

#### Формат входных данных
p m

#### Формат результата
q

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>5 7</td>
    <td valign='top'>3</td>
  </tr>
  <tr>
    <td valign='top'>199212331 4010101141</td>
    <td valign='top'>525555399</td>
  </tr>
</tbody></table>

---

### Последовательность строк (h13_sequence.cpp)
Последовательность строк формируется следующим образом:

Первая строка состоит из цифры 1.

Каждая из последующих строк формируется из номера строки, записанного в виде последовательности десятичных цифр, за которым дописана предыдущая строка и затем перевёрнутая предыдущая строка.

Вот несколько первых строк:<br>
1<br>
211<br>
3211112<br>
432111122111123<br>
5432111122111123321111221111234<br>

Заметьте, что десятая строка начнётся с символов 10, одиннадцатая — с символов 11 и так далее.

Ваша задача заключается в том, чтобы по заданному номеру строки и номеру её элемента вывести символ, стоящий в ней на указанном месте.

#### Формат входных данных
N M<br>
P1 P2 ... PM

Ограничения:<br>
1<=N<=30<br>
1<=M<=100000<br>
1<=Pi<=length(string).

Нумерация строк и символов в строках начинается с единицы.

#### Формат результата
M символов, не разделённых пробелами, соответствующие позициям Pi.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5 5<br>
2 4 6 8 10</td>
    <td valign='top'>42112</td>
  </tr>
</tbody></table>

---

### Перестановки (h14_permutation.cpp)
Как известно, из множества из N различных предметов можно сделать N! различных перестановок.

Если предметы можно сравнивать между собой, то перестановки можно перенумеровать в лексикографическом порядке. Например, перестановки множества {1,2,3} будут идти в следующем порядке: {1,2,3}, {1,3,2}, {2,1,3}, {2,3,1}, {3,1,2}, {3,2,1}.

Таким образом, все перестановки множества различных элементов можно пронумеровать от 1 до N!.

В нашей задаче мы будем переставлять элементы из множества натуральных чисел от 1 до N.

#### Формат входных данных
На вход программы подаётся два числа — количество предметов в перестановке 2<=N<=20 и номер перестановки 1<=M<=2*10e18.

#### Формат результата
Вывести через пробел элементы перестановки, имеющей номер M.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
120</td>
    <td valign='top'>5 4 3 2 1</td>
  </tr>
  <tr>
    <td valign='top'>
10<br>
73238</td>
    <td valign='top'>1 3 9 6 8 4 7 2 10 5</td>
  </tr>
</tbody></table>

---

### Чуждые элементы (h15_alliens.cpp)

Последовательность из 2<=N<=1000000 элементов содержит натуральные числа от 1 до 10e18. Назовём пару соседних чисел, которая имеет общие множители, большие единицы, родственниками. В исходную последовательность вставляют натуральные числа (чуждые элементы) таким образом, что в итоговой последовательности не остаётся родственников. Требуется определить минимально возможную сумму чуждых элементов. Пример: в исходную последовательность<br>
4 8 9 10<br>
можно вставить чуждый элемент 5 после 4:<br>
4 5 8 9 10<br>
после чего последовательность не содержит родственников.

#### Формат входных данных
N<br>
X1<br>
X2<br>
...<br>
XN

#### Формат результата
Sum

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
10<br>
4<br>
8<br>
1<br>
2<br>
4<br>
2<br>
1<br>
7<br>
62<br>
3</td>
    <td valign='top'>3</td>
  </tr>
</tbody></table>

---

### Камера хранения (h21_storeroom.cpp)

На железнодорожном вокзале столицы Бурляндии решили установить новую автоматическую камеру хранения.
Для этого потребовалось узнать, сколько ячеек одновременно занято хранящимся багажом.
Было установлено несколько датчиков использования старой камеры хранения, фиксировавших момент прихода пассажира и занятия им ячейки, а так же момент ухода пассажира и момент освобождения им ячейки.
Протокол прихода и ухода пассажиров за одни сутки приведён далее.
Ячейка не освобождается мгновенно, поэтому если в какое-то время один пассажир ушёл и в это же время пришёл другой пассажир, требуется две ячейки.
Определите максимальное количество одновременно занятых ячеек, наблюдаемое в течении суток.

Камера открыта круглосуточно. Времена прихода и ухода пассажиров находятся в пределах одних суток. В 00:00 камера хранения пуста.

#### Формат входных данных
N (количество пассажиров, 1<=N<=1000000).<br>
HA1:MA1 HD1:MD1<br>
...<br>
HAN:MAN HDN:MDN

#### Формат результата
MaximumNumberOfBusyCells

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
02:18 11:54<br>
03:18 04:16<br>
00:26 20:41<br>
17:19 20:48<br>
08:42 23:45</td>
    <td valign='top'>3</td>
  </tr>
  <tr>
    <td valign='top'>
10<br>
17:59 22:58<br>
12:25 16:06<br>
09:05 18:39<br>
08:34 23:23<br>
15:59 22:53<br>
15:55 21:20<br>
18:05 22:08<br>
03:48 22:23<br>
12:50 14:41<br>
05:46 10:41</td>
    <td valign='top'>7</td>
  </tr>
</tbody></table>

---

### Башня (h22_circus.cpp)
В Бурляндск приехал цирк. Одним из привлекающих внимание горожан номеров всегда было построение как можно более высокой башни из группы циркачей.

В построенной башне один циркач стоит на земле, второй - на его плечах, третий - на плечах второго, и так далее.
У циркача под номером i вес равен wi, а сила — fi.
Сила — способность удерживать на себе заданный вес.
Точно известно, что более тяжёлый циркач является и более сильным.
Впрочем, циркачи с одинаковым весом могут иметь различную силу.

#### Формат входных данных
Первая строка ввода содержит 4<=N<=3000 — количество человек в команде, которые хотят построить башню.

Каждая их последующих строк содержит по два числа — вес и силу участника команды. Все числа — положительные целые, меньшие 10000.

#### Формат результата
Максимальная высота башни, которую может построить эта команда.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
1 9<br>
5 13<br>
13 15<br>
16 20</td>
    <td valign='top'>4</td>
  </tr>
</tbody></table>

---

### Разрезание блинов (h23_cakes.cpp)
На очень большом столе разложено много абсолютно круглых блинов, некоторые из которых могут частично или полностью налегать друг на друга.
Абсолютно прямым ножом проводится луч из первой точки по направлению ко второй.
Требуется определить, какие из блинов будут задеты разрезом. Касания НЕ учитываются.

#### Формат входных данных
В первой строке — координаты двух точек на плоскости, которые определяют луч разреза.
Во второй строке — количество блинов 1<=N<=100000.
В следующих N строках по три числа — координаты центра блина и его радиус.
Все координаты — целые числа от -10000 до 10000.

Радиус — строго положительное целое число.

#### Формат результата
Номера разрезанных блинов в порядке возрастания. Нумерация блинов начинается с 1.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
0 0 0 1<br>
5<br>
-1 -1 1<br>
-2 -2 1<br>
-3 -3 4<br>
1 2 4<br>
3 1 1</td>
    <td valign='top'>4</td>
  </tr>
  <tr>
    <td valign='top'>
0 0 0 1<br>
2<br>
3 0 3<br>
3 0 1</td>
    <td valign='top'></td>
  </tr>
</tbody></table>

---

### Позитивизм (h24_positivism.cpp)
У Иеремии родители — философы. Он часто слышит их разговоры, но мало что в них понимает. Сам Иеремия учится в информатическом классе физматшколы, и философия его пока не интересует.
Недавно он услышал новое для себя слово: позитивизм. Он постеснялся спросить своих родителей, что это слово обозначает, и узнал в Википедии, что-то про эмпирические и философские исследования.
Так как слово ему понравилось, он загорелся идеей провести какие-то исследования, а так, как недавно в школе они проходили матрицы, вопрос, что же будет объектом исследования, оказался для него очевидным.
Он называет позитивной матрицей такую двумерную матрицу, у которой сумма элементов каждой из строк неотрицательна и сумма элементов каждого из столбцов тоже неотрицательна.

Он поставил перед собой задачу установить, каждую ли из матриц можно сделать позитивной, имея ровно две операции: смену всех знаков на противоположные либо для всех элементов строки, либо для всех элементов столбца.
Операции первого вида он записывал, как l y, где y — номер инвертируемой строки, а второго — как c x, где x — номер инвертируемого столбца. И столбцы и строки нумеруются с нуля.
Он проделал серию экспериментов и убедился, что если решение существует, то оно может быть не единственным.

Ваша задача состоит в том, чтобы помочь Иеремии, написав программу, которая либо сообщит, что не существует такой последовательности операций, чтобы матрица стала позитивной, либо выдаст любую последовательность операций, приводящую в конечном итоге к позитивной матрице.

#### Формат входных данных
В первой строке — числа N и M — количество строк и столбцов соответственно. Эти числа не превосходят 100.
В каждой из следующих N строк содержатся значения элементов каждой строки. Ни одно из этих чисел по абсолютной величине не превосходит 10e6.

#### Формат результата
Если матрицу можно сделать позитивной, то решение должно состоять из произвольного числа строк указанного выше вида. Если матрица позитивна с самого начала, программа ничего не должна выводить.
Если её позитивной сделать нельзя, нужно вывести одно слово: Impossible.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
3 3<br>
1 -10 8<br>
2 1   3<br>
1 7   4</td>
    <td valign='top'>
l 0<br>
c 2</td>
  </tr>
  <tr>
    <td valign='top'>
2 2<br>
1 2<br>
3 4</td>
    <td valign='top'></td>
  </tr>
</tbody></table>

---

### Количество подстрок (h25_strings.cpp)
Назовём подстрокой любой набор подряд идущих символов строки. Например, в строке aba можно найти три подстроки длины один: a, b, a, две подстроки длины два: ab и ba, а также одну подстроку длины 3: aba.
Две подстроки здесь совпадают, поэтому различных подстрок здесь 5.
Нужно для заданной строки, состоящей из строчных букв латинского алфавита, определить, сколько в ней можно найти различных подстрок.

#### Формат входных данных
Строка, длиной от 5 до 10000 символов.

#### Формат результата
Количество различных подстрок в данной строке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>abracadabra</td>
    <td valign='top'>54</td>
  </tr>
</tbody></table>

---

### Генератор Гауссовых слов (gausswordgenerator.py)
Гауссово слово – это слово, в котором все буквы встречаются ровно два раза. При этом вначале идет буква a, первая непарная ей – b, следующая непарная им – с, и так далее.
Требуется написать программу, которая выведет все Гауссовы слова из букв от "a" вплоть до введённой латинской буквы.

#### Формат входных данных
Одна буква латинского алфавита.

#### Формат результата
Все возможные Гауссовы слова из заданного диапазона букв по одному слову на строчке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>a</td>
    <td valign='top'>aa</td>
  </tr>
  <tr>
    <td valign='top'>c</td>
    <td valign='top'>
aabbcc<br>
aabcbc<br>
aabccb<br>
ababcc<br>
abbacc<br>
abbcac<br>
abbcca<br>
abacbc<br>
abcabc<br>
abcbac<br>
abcbca<br>
abaccb<br>
abcacb<br>
abccab<br>
abccba</td>
  </tr>
</tbody></table>

---

### Накачка и сброс (pumpndump.py)
Pump'n'dump (накачка и сброс) - это схема относительно честного отъема денег. Она выглядит следуюшим образом. Несколько крупных игроков или много мелких договариваются вместе купить малоизвестную бумагу с низкой ценой и объёмом торгов. Это приводит к мгновенному взлету цены (pump), далее приходят неопытные игроки в надежде успеть заработать на таком росте. В этот момент организаторы схемы начнают все продавать (dump). Весь процесс занимает от нескольких минут до нескольких часов.

Ваша задача найти самый сильный pump'n'dump бумаги на заданном промежутке времени. Для этого для каждого дня определим число pnd, равное отношению максимальной цены бумаги в данный день к максимуму из цен открытия и закрытия в тот же день. Нужно найти день, когда pnd был максимален и его величину.

#### Формат входных данных
На вход подаётся много-много строк в формате дата цена.
Самая первая цена за день - цена открытия.
Самая последняя цена за день - цена закрытия.
Гарантируется, что цены идут в хронологическом порядке.
 
#### Формат результата
Выведите самое большое число pnd

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
2020-07-19 18:00:00 20<br>
2020-07-19 19:00:00 10<br>
2020-07-19 20:00:00 30<br>
2020-07-19 21:00:00 40<br></td>
    <td valign='top'>1</td>
  </tr>
  <tr>
    <td valign='top'>
2020-07-19 21:00:00 20<br>
2020-07-19 22:00:00 10<br>
2020-07-19 23:00:00 40<br>
2020-07-20 00:00:00 50<br>
2020-07-20 01:00:00 10<br>
2020-07-20 02:00:00 20<br>
2020-07-20 03:00:00 15<br>
2020-07-20 04:00:00 60<br>
2020-07-20 05:00:00 10</td>
    <td valign='top'>1.2</td>
  </tr>
  <tr>
<td valign='top'>
2021-03-01 09:30:00 690<br>
2021-03-01 10:30:00 703<br>
2021-03-01 11:30:00 711<br>
2021-03-01 12:30:00 714<br>
2021-03-01 13:30:00 709<br>
2021-03-01 14:30:00 710<br>
2021-03-01 15:30:00 712<br>
2021-03-02 09:30:00 719<br>
2021-03-02 10:30:00 709<br>
2021-03-02 11:30:00 705<br>
2021-03-02 12:30:00 704<br>
2021-03-02 13:30:00 699<br>
2021-03-02 14:30:00 691<br>
2021-03-02 15:30:00 686<br>
2021-03-03 09:30:00 690<br>
2021-03-03 10:30:00 679<br>
2021-03-03 11:30:00 693<br>
2021-03-03 12:30:00 680<br>
2021-03-03 13:30:00 680<br>
2021-03-03 14:30:00 666<br>
2021-03-03 15:30:00 657<br></td>
    <td valign='top'>1.0043478260869565</td>
  </tr>
</tbody></table>

---

### Кубики (cubes.py)
Аня и Боря любят играть в разноцветные кубики, причем у каждого из них свой набор и в каждом наборе все кубики различны по цвету. Однажды дети заинтересовались, сколько существуют цветов таких, что кубики каждого цвета присутствуют в обоих наборах. Для этого они занумеровали все цвета случайными числами. На этом их энтузиазм иссяк, поэтому вам предлагается помочь им в оставшейся части. Номер любого цвета — это целое число в пределах от 0 до 109.

#### Формат входных данных
В первой строке входного файла записаны числа N и M — количество кубиков у Ани и Бори соответственно. В следующих N строках заданы номера цветов кубиков Ани. В последних M строках номера цветов кубиков Бори.
 
#### Формат результата
Выведите сначала количество, а затем отсортированные по возрастанию номера цветов таких, что кубики каждого цвета есть в обоих наборах, затем количество и отсортированные по возрастанию номера остальных цветов у Ани, потом количество и отсортированные по возрастанию номера остальных цветов у Бори.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
4 3<br>
0<br>
1<br>
10<br>
9<br>
1<br>
3<br>
0</td>
    <td valign='top'>
2<br>
0 1<br>
2<br>
9 10<br>
1<br>
3</td>
  </tr>
  <tr>
    <td valign='top'>
2 2<br>
1<br>
2<br>
2<br>
3</td>
    <td valign='top'>
1<br>
2<br>
1<br>
1<br>
1<br>
3</td>
  </tr>
  <tr>
    <td valign='top'>0 0</td>
    <td valign='top'>
0<br>
0<br>
0</td>
  </tr>
</tbody></table>

---

### Продажи (sales.py)
Дана база данных о продажах некоторого интернет-магазина. Каждая строка входного файла представляет собой запись вида Покупатель товар количество, где Покупатель — имя покупателя (строка без пробелов), товар — название товара (строка без пробелов), количество — количество приобретенных единиц товара. Создайте список всех покупателей, а для каждого покупателя подсчитайте количество приобретенных им единиц каждого вида товаров.

#### Формат входных данных
Вводятся сведения о покупках в указанном формате.
 
#### Формат результата
Выведите список всех покупателей в лексикографическом порядке, после имени каждого покупателя выведите двоеточие, затем выведите список названий всех приобретенных данным покупателем товаров в лексикографическом порядке, после названия каждого товара выведите количество единиц товара, приобретенных данным покупателем. Информация о каждом товаре выводится в отдельной строке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
Ivanov paper 10<br>
Petrov pens 5<br>
Ivanov marker 3<br>
Ivanov paper 7<br>
Petrov envelope 20<br>
Ivanov envelope 5</td>
    <td valign='top'>
Ivanov:<br>
envelope 5<br>
marker 3<br>
paper 17<br>
Petrov:<br>
envelope 20<br>
pens 5</td>
  </tr>
  <tr>
    <td valign='top'>
Ivanov aaa 1<br>
Petrov aaa 2<br>
Sidorov aaa 3<br>
Ivanov aaa 6<br>
Petrov aaa 7<br>
Sidorov aaa 8<br>
Ivanov bbb 3<br>
Petrov bbb 7<br>
Sidorov aaa 345<br>
Ivanov ccc 45<br>
Petrov ddd 34<br>
Ziborov eee 234<br>
Ivanov aaa 45</td>
    <td valign='top'>
Ivanov:<br>
aaa 52<br>
bbb 3<br>
ccc 45<br>
Petrov:<br>
aaa 9<br>
bbb 7<br>
ddd 34<br>
Sidorov:<br>
aaa 356<br>
Ziborov:<br>
eee 234</td>
  </tr>
</tbody></table>

---

### Слишком серьёзная задача (tooserious.py)
Эконом прослушал курс по финансовым рынкам. Он показался ему слишком практическим. Теперь надо как-то применять знания на практике. Поэтому все скачали себе Пенькоф-Инвестиции и начали торговать. Это не является инвестиционной рекомендацией.
Давайте немного помечтаем и представим, что нам стало так везти, что для любой ценной бумаги в любой день мы умудряемся купить её по минимальной цене и в тот же день продать по максимальной.
Страшно подумать, как можно было бы приумножить свой капитал всего лишь за несколько дней...

Ваша задача - узнать во сколько раз вырастут ваши вложения при такой удаче. Все заработанные деньги вы реинвестируете. Короткие позиции запрещены. Продавать раньше, чем покупать запрещено. У вас нет премиум-аккаунта.

#### Формат входных данных
На вход подаётся много-много строк в формате дата цена. Гарантируетcя, что цена изменяется от 0 до 106.

#### Формат результата
Выведите свою максимальную доходность. В процентах. Сумма, которую вы изначально вкладываете в бумагу - неважна.

#### Комментарий к примерам
1. Есть 100 рублей. Мы купили бумаги по 10 и продали по 40. В итоге у нас 400 рублей. Итоговая доходность 100*(40 - 10)/10 = 300%
2. Есть 100 рублей. Мы купили бумаги по 20 и продали по 40. Ко второму дню у нас есть 200 рублей. Все полученные деньги мы реинвестировали. Купили за 20, продали за 60. В итоге у нас 600 рублей. Итоговая доходность 500%.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
2020-07-19 18:00:00 20<br>
2020-07-19 19:00:00 10<br>
2020-07-19 20:00:00 30<br>
2020-07-19 21:00:00 40</td>
    <td valign='top'>300</td>
  </tr>
  <tr>
    <td valign='top'>
2020-07-19 21:00:00 20<br>
2020-07-19 22:00:00 40<br>
2020-07-19 23:00:00 10<br>
2020-07-20 00:00:00 20<br>
2020-07-20 01:00:00 60<br>
2020-07-20 02:00:00 30</td>
    <td valign='top'>500</td>
  </tr>
</tbody></table>

---

### Очень быстрая сортировка (radix_sort.cpp)
Уметь сортировать быстро – полезный навык. Стандартные сортировки в языках Си и C++ достаточно быстры и универсальны. К сожалению, их универсальность имеет недостаток: сложность алоритмов этих сортировки составляет O(N log(N)).
Между тем известно, что для некоторых типов данных имеются и сортировки со сложность по времени O(N).
Вам и предстоит такую написать.

Файл, который вы должны послать в тестирующую систему, должен иметь реализацию ровно одной функции. Она должна ничего не вводить и ничего не выводить.
```
void fast_sort(unsigned *begin, unsigned *end) {
    // Your code for implementation
}
```
Требуется, чтобы ваша функция отсортировала массив, заданный аргументами, по возрастанию.
Ваша программа не должна содержать функции main.

#### Пример
Пример программы, которую можно использовать при тестировании:
```
int main() {
    unsigned array[8] = {3,1,4,1,5,9,2,6};
    fast_sort(array, array+8);
    // Now array = {1,1,2,3,4,5,6,9}
}
```

---

### Факториальная система счисления (r11_factradix.cpp)
Наряду с уже привычными позиционными системами счисления, к которым мы все уже привыкли, существует множество других, всё также позиционных, но с другими правилами вычисления весов позиций.
Мы рассмотрим факториальную систему счисления, в которой вес каждой позиции — факториал от её номера. Для позиций после десятичной точки используются обратные к факториалам веса.
Каждая правильная дробь (p < q) представляется в такой системе единственным конечным образом при условии, что в самом правом члене записи коэффициент отличен от нуля.
Ваша задача — найти такие числа ai < i, чтобы сумма их произведений на факториалы их индексов i равнялась заданной дроби.

#### Формат входных данных
1 <= P < Q < 1000

#### Формат результата
В одной строке через пробел выведите коэффициенты разложения, начиная с a2.

Гарантируется, что число выводимых членов будет меньше 1000.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>1 4</td>
    <td valign='top'>0 1 2</td>
  </tr>
  <tr>
    <td valign='top'>5 7</td>
    <td valign='top'>1 1 1 0 4 2</td>
  </tr>
</tbody></table>

---

### Танец точек (r12_dance.cpp)
На прямой располагается 1<=N<=10000 точек с целочисленными координатами −10e9<=Vi<=10e9.
Каждой из точек разрешается сделать ровно одно движение (танцевальное па) в любом направлении на расстояние не больше 0<=L<=10e8 и остановиться на другой позиции.
Какое минимальное количество точек может оказаться после окончания танца (все точки после танца, оказывающиеся на одной позиции сливаются в одну)?

#### Формат входных данных
L N<br>
V1<br>
V2<br>
...<br>
VN

#### Формат результата
MinimalNumberOfPoints

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
10 5<br>
30 3 14 19 21</td>
    <td valign='top'>2</td>
  </tr>
</tbody></table>

---

### Офисное здание (r13_complaints.cpp)
Эта задача аналогична задаче h21_storeroom за исключением точности до секунд.

В одной очень большой стране в одном очень большом городе стояло очень-очень большое здание, в котором граждане этой страны подавали жалобы на других граждан. Так как жалобщиков было очень много, оно работало круглосуточно, но каждый из посетителей, пришедших в какое-то время после нуля часов, был обязан покинуть здание до 24 часов.
Клерков, принимающих жалобы, было не очень много, из-за чего гражданам приходилось сидеть и ждать в очереди, пока нужный клерк освободится.
На эту организацию, принимающую жалобы, в неё же поступила жалоба, что жалобы рассматриваются недостаточно быстро и вам было поручено определить, а сколько же жалобщиков одновременно находится в здании. К счастью для вас, во всех жителей этой страны были встроены чипы, точно определяющие положение в любой момент времени.
Вам был дан доступ к данным за сутки. В 00:00:00 здание жалобщиков не ещё не содержало, а в 24:00:00 уже не содержало, так как все жалующиеся покинули здание. Дверей в здании много, поэтому вполне могли случаться такие ситуации, когда в одну и ту же секунду один жалобщик прибывал, а другой — покидал помещение. В таком случае оба считались находящимися в здании.
Ваша задача — определить максимальное число жалобщиков, одновременно находящихся в здании.

#### Формат входных данных
На вход программы подаётся число 1<=N<=200000 — число записей в базе данных. Каждая запись имеет содержит два времени с точностью до секунд — время прибытия и время убытия в формате HH:MM:SS.

#### Формат результата
Одно число — максимальное количество жалобщиков, одновременно находящихся в здании.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
02:03:42 20:44:18<br>
02:01:25 13:54:01<br>
13:04:48 23:39:34<br>
02:08:16 19:30:44<br>
01:02:34 08:00:07</td>
    <td valign='top'>4</td>
  </tr>
</tbody></table>

---
### Подмножества (r14_subsets.cpp)
Множество задано строкой, то есть каждая буква есть элемент множества.
Но это множество — не совсем простое. Элементы в нём могут повторяться.
Два подмножества считаются одинаковыми, если все элементы одного множества совпадают с элементами другого. Например, множества, представленные строками abc и cba совпадают. Совпадают также множества abra и raba.
Ваша задача по заданной строке, представляющей исходное множество, вывести все различные его подмножества, каждое на отдельной строке вывода. Выводить можно в произвольном порядке. Выход не должен содержать совпадающие подмножества.
Пустое множество тоже является подмножеством исходного.

#### Формат входных данных
Исходное множество в виде строки

#### Формат результата
Все уникальные подмножества исходного множества по одному на строку. Подмножества не требуется как-либо упорядочивать, будет принят любой верный ответ.

Не забудьте, что пустая строка — тоже верное подмножество. В приведённом примере она следует первой, перед строкой a.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>abra</td>
    <td valign='top'>
<br>
a<br>
b<br>
ba<br>
ar<br>
rb<br>
aa<br>
raab<br>
baa<br>
abr<br>
ara<br>
r</td>
  </tr>
  <tr>
    <td valign='top'>
<br></td>
    <td valign='top'>
<br></td>
  </tr>
  <tr>
    <td valign='top'>Q1aQQ</td>
    <td valign='top'>
QQa<br>
Qa<br>
1<br>
QQ<br>
1a<br>
QQQa<br>
QQQ<br>
1QQQ<br>
a<br>
1Q<br>
1QQ<br>
<br>
1QQQa<br>
1QQa<br>
Q<br>
1Qa</td>
  </tr>
</tbody></table>

---
### Игра в 2048 (game2048.cpp)
Петя решил поиграть в известную игру 2048. Но играть в классическую версию ему уже неинтересно и он разработал улучшенную версию. У игрока имеется набор из нескольких чисел, где каждое число - степень двойки с натуральным показателем, не превыщающим n. Каждый ход игрок может сделать одно из следующих действий:

Сгенерировать число 2^k, это действие занимает ak секунд.

Умножить все имеющиеся числа на 2. При этом, если вы умножаете на 2 число 2^n, оно превращается в число 2. Такое действие занимает x секунд.

Например, если вы собрали набор 2, 32, 128 и n=7, то после выполнения второго действия у вас будет набор 4, 64, 2.
Игра заканчивается, когда вы собираете ровно n чисел, и все они различны. Изначально у игрока нет чисел. Все ходы выполняются последовательно, один за одним.
Петя решил провести соревнования по новой игре, и вы принимаете в нём участие. Спланируйте свою тактику так, чтобы быстрее всего закончить игру.

#### Формат входных данных
В первой строке даны два натуральных числа n (2<=n<=2000) и x (1<=x<=10e9) - требуемое количество чисел и время работы умножителя.
Во второй строке задано n целых чисел ai (1<=ai<=10e9) - время генерации числа 2^i.

#### Формат результата
Выведите одно число - минимальное количество времени, необходимое для прохождения игры.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
3 5<br>
1 2 3</td>
    <td valign='top'>6</td>
  </tr>
  <tr>
    <td valign='top'>
4 5<br>
1 100 3 4</td>
    <td valign='top'>13</td>
  </tr>
</tbody></table>

#### Замечание
В первом тесте невыгодно использовать второе действие, поэтому просто последовательно сгенерируем все степени двойки.
Во втором тесте выгодно сгенерировать за первые два хода (2,8), после этого умножить их на два, получить набор (4,16), и за два хода сгенерировать 2 и 8. Ответ: 1+3+5+1+3=13.

---
### Несколько классов (several_classes.cpp)
Разработать набор классов, объекты которых реализуют типы данных, указанные ниже.
С помощью перегрузки операторов (operator) разработать стандартную арифметику объектов, включающую арифметические действия над объектами и стандартными типами (целыми, вещественными, строками – в зависимости от вида объектов), присваивание, ввод и вывод в стандартные потоки (используя операторы «<<» и «>>»), приведение к/от базового типа данных.
Организовать операции в виде конвейера значений, с результатом (новым объектом) и сохранением значений входных операндов.

1. Дата и время, представленные целочисленными переменными: год, месяц, день, час, минута, секунда.
Базовый тип: uint64_t формат представления unix time.
Реализовать возможность преобразования в/из формата представления filetime (целое 64-х разрядное значение, представляющее число интервалов по 100 наносекунд, прошедших с первого января 1601 года).

2. Год «от Адама», имеющий внутреннее представление в виде целочисленных переменных: индикт, круг солнцу, круг луне. Диапазоны значений (циклические): индикт 1—15, круг солнцу 1—28, круг луне 1—19. Ежегодно каждая переменная увеличивается на 1. Итоговое значение вычисляется как произведение переменных (диапазона на некоторый множитель; переменные независимы), а хранимое значение является остатком от деления (на диапазон), при этом 0 соответствует максимум.
Необходима возможность отображения/задания как в виде одного числа, так и виде трех.
Реализовать возможность преобразования в/из формата представления «от рождества Христова» используя соответствие 1652 = 7160 «от Адама».

3. Разреженная матрица, представленная динамическим массивом структур, содержащих описания ненулевых коэффициентов: индексы местоположения коэффициента в матрице (целые) и значение коэффициента (вещественное).

---
### Агата и Кристи (agata_kristie.cpp)

Кристи и Агата – лучшие подруги. Они любят проводить свободное время за разгадыванием головоломок. В этот раз загадку подготовила Кристи, помогите Агате справиться с задачей. Даны n чисел ai (1 <= ai <= 200000). Также имеются q запросов вида (lj , rj) – такой запрос означает, что надо сложить все числа на отрезке от lj до rj включительно и вернуть полученную сумму. Кристи дала Агате набор чисел и сами запросы. Задача Агаты – расставить числа ai на позициях от 1 до n (по одному на позицию) так, чтобы сумма ответов на все q запросов была как можно больше. Помогите Агате!

#### Формат входных данных
В первой строке через пробел даны количество чисел в наборе – n (1 <= n <= 200000) и количество запросов q (1 <= q <= 200000). Во второй строке даны числа ai (1 <= ai <= 200000), записанные через пробел. В следующих q строках даны запросы по одному в строке. Запрос j состоит из двух чисел lj и rj , записанных через пробел (1 <= lj <= rj <= n).

#### Формат результата
Выведите единственное число – максимальную сумму ответов на запросы, которую может получить Агата.

#### Примеры 
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5 3<br>
1 9 4 3 1<br>
1 4<br>
2 2<br>
3 5</td>
    <td valign='top'>34</td>
  </tr>
  <tr>
    <td valign='top'>
1 1<br>
5<br>
1 1</td>
    <td valign='top'>5</td>
  </tr>
  <tr>
    <td valign='top'>
2 2<br>
8 4<br>
1 1<br>
2 2<br>
1 1</td>
    <td valign='top'>12</td>
  </tr>
</tbody></table>

---
### Физрук Арсений (gym_teacher.cpp)

В начале урока физкультуры ученики 13А класса выстроились в ряд. Физрук Арсений любит порядок, но школьники опять встали не по росту. Он решил проучить их и выбрать какой-то хороший отрезок детей, и отправить их играть в волейбол, а остальных оставить выполнять нормативы. Хорошим отрезком детей Арсений называет такой непрерывный отрезок детей в ряду, что их рост строго убывает. Ученики любят волейбол, поэтому хотят понять, есть ли у них шанс оказаться в числе счастливчиков. Для этого каждый школьник хочет выяснить, как много людей может пойти играть с ним в волейбол, то есть найти длину наибольшего хорошего отрезка, содержащего его самого.

#### Формат входных данных
Первая строка содержит одно целое число n (1 <= n <= 100000) — количество учеников 13А, пришедших на урок.
Вторая строка содержит n целых чисел a1, a2, ..., an (1 <= ai <= 1000000000) — рост школьников в том порядке, в котором они встали изначально.

#### Формат результата
Выведите n целых чисел через пробел, где i-е число — максимальная длина хорошего отрезка, содержащего школьника номер i.

Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
7 4 2 2 10</td>
    <td valign='top'>3 3 3 1 1</td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
2 4 6 4 2</td>
    <td valign='top'>1 1 3 3 3</td>
  </tr>
</tbody></table>

---
### Гурман (gourmet.cpp)

Нитуширг в жизни больше всего любит две вещи - вкусно поесть и отдыхать на море. Поэтому он решил совместить приятное с приятным и поехать на пятизвёздочный морской курорт Фокьнит. Но вот незадача: в Фокьните есть только одна столовая, меню в которой каждый день заранее фиксировано. Поскольку Нитуширг - гурман, он предпочитает разнообразие в еде, поэтому если за время отдыха какое-то меню попадётся более K раз - Нитуширг очень расстроится и весь отпуск пойдёт насмарку. При этом, разумеется, Нитуширг хочет отдохнуть на море как можно дольше. Ваша задача состоит в том, чтобы по известному заранее меню столовой на N дней выбрать как можно более длинный отрезок подряд идущих дней, в которые Нитуширг поедет в Фокьнит так, чтобы никакой набор блюд не повторялся более K раз за всё время поездки.

#### Формат входных данных
В первой строке вам даны целые числа 1 <= N <= 100000 и 1 <= K <= N - количество дней, когда Фокьнит открыт для гостей и K - максимальное количество раз, которое может повториться меню за время отпуска. В следующей строке входного файла вам дана строка, состоящая из N строчных латинских букв. Каждая буква означает свой вариант меню, разным меню соответствуют разные буквы.

#### Формат результата
На выход ваша программа должна вывести два целых числа: 1 <= L <= N - максимальное количество дней отпуска Нитуширга и 1 <= d0 <= N - номер дня заезда. Считайте, что в день заезда Нитуширг успевает съесть предлагаемое столовой меню.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
1 1<br>
a</td>
    <td valign='top'>1 1</td>
  </tr>
  <tr>
    <td valign='top'>
6 2<br>
abbbaa</td>
    <td valign='top'>4 3</td>
  </tr>
</tbody></table>

---

### Структура данных - Дек (data_structure_deck.py)
Гоша реализовал структуру данных Дек, максимальный размер которого определяется заданным числом. Методы push_back(x), push_front(x), pop_back(), pop_front() работали корректно. Но, если в деке было много элементов, программа работала очень долго. Дело в том, что не все операции выполнялись за О(1). Помогите Гоше! Напишите эффективную реализацию. При реализации нельзя использовать связный список.

#### Формат входных данных
В первой строке записано количество команд n - целое число, не превосходящее 5000. Во второй строке записано число m - максимальный размер дека. Он не превосходит 1000. В следующих n строках записана одна из команд:
* push_back(value) - добавить элемент в конец дека. Если в деке уже находится максимальное число элементов, вывести 'error'.
* push_front(value) - добавить элемент в начало дека. Если в деке уже находится максимальное число элементов, вывести 'error'.
* pop_back() - вывести последний элемент дека и удалить его. Если дек был пуст, то вывести 'error'.
* pop_front() - вывести первый элемент дека и удалить его. Если дек был пуст, то вывести 'error'.
value - целое число, по модулю не превосходящее 1000.

#### Формат результата
Выведите результат выполнения кадой команды на отдельной строке. Для успешных запросов push_back(x) и push_front(x) ничего выводить не надо.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
4<br>
push_front 861<br>
push_front -819<br>
pop_back<br>
pop_back</td>
    <td valign='top'>861<br>
-819</td>
  </tr>
  <tr>
    <td valign='top'>
7<br>
10<br>
push_front -855<br>
push_front 720<br>
pop_back<br>
pop_back<br>
push_back 844<br>
pop_back<br>
push_back 823</td>
    <td valign='top'>
-855<br>
720<br>
844</td></tr>
</tbody></table>

---

### Сжиматель фоток (BMP_image_resizer/BMP_image_resizer.cpp)
В файле pic.bmp задано изображение в формате True Color 32 бита на пиксел. Написать программу на языке C++, которая загружает это изображение в программу, масштабирует изображение таким образом, чтобы его ширина и высота уменьшились бы втрое и выводит в файл pic2.bmp.
В каждой точке создаваемого изображения каждая компонента цвета должна быть выбрана в виде среднего значения из девяти значений из квадрата 3х3 вокруг соответствующей точки на исходном изображении. В граничных точках размер области вокруг соответствующей точки на исходном изображении может быть меньше.
Вся отведенная память в программе должна быть очищена. Все открытые файлы должны быть закрыты.
