# minorProjects
This repository contains programming tasks gathered from different programming language courses.
Tasks are sorted by addition order.

---

<details>
<summary>
<b>Задача о рюкзаке (backpack.cpp)</b>
</summary>
<br>
Решить задачу о рюкзаке методом динамического программирования. Алгоритм должен быть инкапсулирован.

#### Формат входных данных
Данные подаются на стандартный поток ввода. Пустые строки игнорируются.
Первая строка содержит натуральное число - максимальную массу предметов, которую выдержит рюкзак.
Каждая последующая содержит два неотрицательных числа: массу предмета и его стоимость.

#### Формат результата
Первая строка содержит два числа: суммарную массу предметов и их суммарную стоимость.
В последующих строках записаны номера предметов, которые были помещены в рюкзак, в порядке возрастания номера.
Результат работы программы выводится в стандартный поток вывода.
В любой непонятной ситуации результатом работы любой команды будет "error".

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
165<br>
23 92<br>
31 57<br>
29 49<br>
44 68<br>
53 60<br>
38 43<br>
63 67<br>
85 84<br>
89 87<br>
82 72
</td>
  <td valign='top'>
165 309<br>
1<br>
2<br>
3<br>
4<br>
6
</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Сумасшедший богач (millionaire_dynamic.py, millionaire_fastest.py)</b>
</summary>
<br>

Один сумасшедший богач на старости лет впал в маразм и стал еще более сумасшедшим. Он решил отдать половину своих богатств тому, кто выиграет в математической игре.
Правила игры: изначально каждый игрок начинает с нулевой суммой. Он может либо получить у богача 1 миллион сантиков, либо отдать ему 1 миллион сантиков, либо получить от богача ту же сумму, которая есть у него сейчас.
Выигрывает тот, кто за минимальное количество действий наберет сумму, равную половине состояния богача.
На беду других игроков, нашелся человек, который что-то слышал про жадные алгоритмы и двоичную систему счисления (возможно это вы).

#### Формат входных данных
В стандартном потоке записано единственное натуральное число - размер половины состояния богача (в миллионах).

#### Формат результата
Каждая строка выхода содержит ровно одну операцию (inc, dec или dbl) из кратчайшей последовательности действий для победы.
Результат работы программы выводится в стандартный поток вывода.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign="top">23</td>
    <td valign="top">
inc<br>
dbl<br>
inc<br>
dbl<br>
dbl<br>
dbl<br>
dec
</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Автокоррекция (word_correction.py)</b>
</summary>
<br>

Реализуйте программу, которая предлагает варианты замены слова, в котором допущена одна ошибка.
Эту задачу можно решить достаточно многими способами - на это ограничений нет, но код должен быть хорошего качества и читаемым.
Регистр букв для программы коррекции не имеет значения (слова в словаре хранятся в нижнем регистре).
Варианты ошибок - как в алгоритме Дамерау-Левенштейна: вставка лишнего символа, удаление символа, замена символа или транспозиция соседних символов.

#### Формат входных данных
Данные подаются на стандартный поток ввода. Пустые строки игнорируются.
Первая строка содержит число N - количество слов в словаре.
Последующие N строк содержат слова из словаря, по одному в строке.
Остальные строки - слова, которые надо проверять.

#### Формат результата
Каждая строка выхода содержит предложение для исправления слов, в порядке их появления.
Если слово не содержит ошибок, то выводится "%слово% - ok".
Если слово содержит одну ошибку, то выводится "%слово% -> %слово_в_словаре%". Если вариантов несколько, то они разделяются запятой с пробелом.
Если слово содержит более одной ошибки, то выводится "%слово% -?"
Результат работы программы выводится в стандартный поток вывода.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign="top">
8<br>
some<br>
random<br>
words<br>
for<br>
testing<br>
your<br>
solutions<br>
far<br>
<br>
some<br>
randoms<br>
wards<br>
seeking<br>
fro<br>
solution<br>
fur
</td>
    <td valign="top">
some - ok<br>
randoms -&gt; random<br>
wards -&gt; words<br>
seeking -?<br>
fro -&gt; for<br>
solution -&gt; solutions<br>
fur -&gt; far, for
</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Разложение на слагаемые (decompose.cpp, decompose2.cpp)</b>
</summary>
<br>

Дано натуральное число N. Рассмотрим его разбиение на различные натуральные слагаемые. Два разбиения, отличающихся только порядком слагаемых, будем считать за одно, поэтому можно считать, что слагаемые в разбиении упорядочены по невозрастанию.

#### Формат входных данных
Задано единственное число N. (N ≤ 40)

#### Формат результата
Необходимо вывести все разбиения числа N на различные натуральные слагаемые в обратном лексикографическом порядке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign="top">5</td>
    <td valign="top">
5<br>
4 1<br>
3 2<br>
3 1 1<br>
2 2 1<br>
2 1 1 1<br>
1 1 1 1 1
</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Максимальный палиндром (maxpalindrome.py)</b>
</summary>
<br>

Палиндром - это строка, которая читается одинаково как справа налево, так и слева направо.

На вход программы поступает набор больших латинских букв (не обязательно различных). Разрешается переставлять буквы, а также удалять некоторые буквы. Требуется из данных букв по указанным правилам составить палиндром наибольшей длины, а если таких палиндромов несколько, то выбрать первый из них в алфавитном порядке.

#### Формат входных данных
В первой строке входных данных содержится число N (1 <= N <= 100000). Во второй строке задается последовательность из N больших латинских букв (буквы записаны без пробелов).

#### Формат результата
В единственной строке выходных данных выдайте искомый палиндром.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign="top">
3<br>
AAB</td>
    <td valign="top">ABA</td>
  </tr>
  <tr>
    <td valign="top">
6<br>
QAZQAZ</td>
    <td valign="top">AQZZQA</td>
  </tr>
  <tr>
    <td valign="top">
6<br>
ABCDEF</td>
    <td valign="top">A</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Сортировка матрицы (matrixSort.cpp)</b>
</summary>
<br>

Напишите алгоритм сортировки двумерного массива n на n такой, что A[i][j] ≤ A[k][m], если i+j < k+m.
Внутри антидиагонали упорядоченность по возрастанию по строкам.
Постарайтесь использовать O(1) памяти.
Реализация алгоритма должна быть инкапсулирована.

#### Формат входных данных
Данные подаются на стандартный поток ввода.
Первая строка содержит число N - размерность массива.
Последующие N строк содержат N целых неотрицательных чисел, помещающихся в int32.

#### Формат результата
Вывод результирующей матрицы построчно через пробел.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign="top">
3<br>
1 3 2<br>
7 8 9<br>
6 8 9
</td>
    <td valign="top">
1 2 6<br>
3 7 8<br>
8 9 9
</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Быстрая сортировка (quicksort.py)</b>
</summary>
<br>

Реализуйте эффективный алгоритм быстрой сортировки.

#### Формат входных данных
Ввод осуществляется со стандартного потока ввода.
Первая и единственная строка всегда содержит входной массив.
Все данные гарантированно валидны, проверять данные на корректность не нужно.

#### Формат результата
Результат работы - отсортированный массив.
Результат работы программы выводится в стандартный поток вывода.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>4 3 5 1 2</td>
    <td valign='top'>1 2 3 4 5</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Бинарный поиск (binarysearch.py)</b>
</summary>
<br>

Реализуйте рекурсивно алгоритм бинарного поиска.
Реализация алгоритма должна быть инкапуслирована, т.е. не зависеть от форматов входных/выходных данных и непосредственно ввода/вывода.

#### Формат входных данных
Ввод осуществляется со стандартного потока ввода.
Первая строка всегда содержит отсортированный массив, в котором должен производится поиск.
Остальные строки имеют формат search K, где K - некоторое число.
Все данные гарантированно валидны, проверять данные на корректность не нужно.

#### Формат результата
Результат поиска - индекс числа в массиве. Если число в массиве отсутствует, то результатом будет -1.
Результат работы программы выводится в стандартный поток вывода.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
10 20 30 40 50 60 70 80<br>
search 30<br>
search 5
    </td>
    <td valign='top'>
2<br>
-1</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Перестановки (permutations.py)</b>
</summary>
<br>

Реализуйте алгоритм генерации перестановок с началом в произвольной перестановке.
Реализация алгоритма должна быть инкапсулирована и не зависеть от ввода/вывода.

#### Формат входных данных
На стандартном потоке ввода в первой и единственной строке задаётся перестановка — несколько чисел, разделенных пробелами.

#### Формат результата
На стандартный поток вывода выводятся построчно все последующие перестановки, включая входную, в лексикографическом порядке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>3 2 1 4</td>
    <td valign='top'>
3 2 1 4<br>
3 2 4 1<br>
3 4 1 2<br>
3 4 2 1<br>
4 1 2 3<br>
4 1 3 2<br>
4 2 1 3<br>
4 2 3 1<br>
4 3 1 2<br>
4 3 2 1<br>
1 2 3 4<br>
1 2 4 3<br>
1 3 2 4<br>
1 3 4 2<br>
1 4 2 3<br>
1 4 3 2<br>
2 1 3 4<br>
2 1 4 3<br>
2 3 1 4<br>
2 3 4 1<br>
2 4 1 3<br>
2 4 3 1<br>
3 1 2 4<br>
3 1 4 2
    </td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Самый частый элемент массива (mostcommon.py)</b>
</summary>
<br>

Реализуйте алгоритм поиска наиболее частого элемента массива, который работает за линейное время.

#### Формат входных данных
Ввод осуществляется со стандартного потока ввода.
Первая и единственная строка всегда содержит входной массив.
Все данные гарантированно валидны, проверять данные на корректность не нужно.

#### Формат результата
Результат поиска - самый частый элемент массива. Если таких чисел несколько, то наименьшее из них.
Результат работы программы выводится в стандартный поток вывода.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>2 5 1 3 5 4 2 3 5 4 3 4 5 4 5</td>
    <td valign='top'>5</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Самый частый элемент массива 2 (mostcommon2.cpp)</b>
</summary>
<br>

Реализуйте алгоритм поиска наиболее частого элемента массива, который работает за линейное время.

#### Формат входных данных
На вход подается количество чисел n, после которого идет n чисел.
Числа и их количество не превышают 1000000.

#### Формат результата
Результат поиска - самый частый элемент массива. Если таких чисел несколько, то наименьшее из них.
Результат работы программы выводится в стандартный поток вывода.
После числа с наибольшим количеством упоминаний вывести медианное число (в случае четного количества чисел, вывести минимальное).

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
2<br>
4 5</td>
    <td valign='top'>4 4</td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
8 8 8 8</td>
    <td valign='top'>8 8</td>
  </tr>
  <tr>
    <td valign='top'>
8<br>
9 7 8 3 1 9 7 7</td>
    <td valign='top'>7 7</td>
  </tr>
  <tr>
    <td valign='top'>
7<br>
4 8 5 7 8 4 9</td>
    <td valign='top'>4 7</td>
  </tr>
  <tr>
    <td valign='top'>
3<br>
6 9 1</td>
    <td valign='top'>1 6</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Сферы в параллелепипедах (spheresinside.py)</b>
</summary>
<br>

В трёхмерном пространстве описан набор сфер и прямоугольных параллелепипедов. Требуется определить, находятся ли все сферы внутри параллелепипедов или нет.

#### Формат входных данных
В первой строке через пробел записаны 2 целых числа M и K - количество сфер и параллелепипедов соответственно.
Оба числа не превышают 10. Далее идёт M строк по 4 числа в строке через пробел: целочисленные координаты X,Y,Z центров сфер (не превышают по модулю 1000) и целочисленный радиус (от 1 до 100). Далее - K строк, описывающих параллелепипеды, по 24 целых числа - координат вершин (не превышают по модулю 2000) в строке через пробел: X1 Y1 Z1 X2 Y2 Z2 X3 Y3 Z3 X4 Y4 Z4 X5 Y5 Z5 X6 Y6 Z6 X7 Y7 Z7 X8 Y8 Z8.

#### Формат результата
Номера сфер по порядку ввода (нумерация начинается с 1), которые не находятся полностью в параллелепипедах.

Параллелепипеды не могут быть вложены друг в друга, между собой не пересекаются и не соприкасаются.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
2 1<br>    
1 1 1 1<br>
10 10 10 2<br>
0 0 0 10 0 0 0 10 0 10 10 0 0 0 10 10 0 10 0 10 10 10 10 10
    </td>
    <td valign='top'>2</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Последняя цифра (lastdigit.py)</b>
</summary>
<br>

Для заданного в некоторой системе счисления числа N определить последнюю цифру числа N^k.

#### Формат входных данных
В строке через пробел записаны число C - основание системы счисления от 2 до 20, целое число N (не более 5 разрядов, в C-й системе счисления) и положительная целая степень k в десятичной системе счисления, не превышающая 100.

#### Формат результата
Последняя цифра N^k в C-й системе счисления.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>2 111 3</td>
    <td valign='top'>1</td>
  </tr>
  <tr>
    <td valign='top'>16 AE 2</td>
    <td valign='top'>4</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Минимальное число контейнеров (mincontainers.py)</b>
</summary>
<br>

Мама Малыша готовится к приёму гостей, ей срочно нужно приготовить очень много тефтелей. Готовые тефтели она решила раскладывать по кастрюлям и позвала Малыша помочь принести нужные кастрюли. Помогите Малышу определить минимальное количество кастрюль, которые потребуются.

#### Формат входных данных
В первой строке через пробел записаны целые числа N и M - минимальный общий объём кастрюль, который понадобится, и количество свободных кастрюль на кухне.
Далее M строк, в каждой записано по одному вещественному числу - объём соответствующей кастрюли.

#### Формат результата
Номера кастрюль, которые надо принести Малышу, записанные по одному в строке, в порядке возрастания. Номера считать по порядку входных данных, начиная с единицы.
Если подходит несколько возможных вариантов, то Малышу требуется принести самые большие кастрюли.
В случае, если подходящих кастрюль нет, вывести слово NO.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5 4<br>
1<br>
3.5<br>
2<br>
4
    </td>
    <td valign='top'>
2<br>
4
    </td>
  </tr>
  <tr>
    <td valign='top'>
3 5<br>
1<br>
0.8<br>
1.2<br>
2<br>
1.5
    </td>
    <td valign='top'>
4<br>
5
    </td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Мороженое и холодильник (refrigerator.java)</b>
</summary>
<br>

Харитон любит мороженое.
В своём любимом магазине мороженого Харитон каждому сорту мороженого присвоил рейтинг.
Чем больше этот рейтинг, тем вкуснее мороженое с точки зрения Харитона.
Каждый день в киоске некоторое мороженое назначаются мороженым дня и продают со скидкой.
Харитон любит экономить, поэтому он покупает только мороженое дня или не покупает мороженого вообще.
Если рейтинг мороженого дня не меньше, чем рейтинг самого вкусного мороженого, хранящегося в холодильнике Харитона, то он купит две порции этого мороженого.
Одну съест сразу, а вторую положит в холодильник.
Иначе Харитон не будет ничего покупать и съест самое вкусное мороженое из своего холодильника.

Требуется по заданной информации о мороженых дня за n дней определить, какое максимальное количество порций мороженого одновременно оказывалось в холодильнике Харитона на протяжении этих n дней.
А также какое мороженое Харитон покупал чаще всего.

#### Формат входных данных
В первой строке содержится целое число (1<=n<=300000) - количество дней, для которых имеется информация о мороженом.

В каждой из следующих n строк содержится информация о мороженом дня в соответствующий день: наименование сорта мороженного s_j и через пробел его рейтинг r_j (0<=r_j<=1000000).

Наименование сорта мороженого s_j - непустая строка из строчных латинских букв, цифр и нижнего подчёркивания, начинающаяся с буквы и имеющая длину не более 30 символов.

Гарантируется, что для фиксированного наименования мороженого рейтинг сорта мороженого постоянный.

#### Формат результата
В первой строке выведите целое число m - максимальное число одновременно лежавших в холодильнике порций мороженого.

Во второй строке вывести целые числа v и k - максимальное количество раз, которое Харитон покупал мороженое одного и того же сорта, и количество сортов мороженого, которые Харитон покупал чаще всего.

Далее выведите k строк, в каждой строке укажите по одному наименованию сорта мороженого, которое Харитон покупал чаще всего.
Наимеинования сортов выводите в лексикографическом (алфавитном) порядке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
14<br>
strawberry 3<br>
vanilla 5<br>
blackberry 4<br>
banana 3<br>
strawberry 3<br>
watermelon 2<br>
lemon 6<br>
vanilla 5<br>
blackberry 4<br>
vanilla2 4<br>
strawberry 3<br>
vanilla2 4<br>
vanilla 5<br>
strawberry 3
    </td>
    <td valign='top'>
5<br>
2 3<br>
strawberry<br>
vanilla<br>
vanilla2
	</td>
  </tr>
</tbody></table>


</details>

---

<details>
<summary>
<b>Мороженое и холодильник 2 (refrigerator2.java)</b>
</summary>
<br>

Харитон решил изменить стратегию.
Он не станет покупать мороженое в двух случаях:
* Если в холодильнике имеется мороженое, которое лежит там уже d дней. В этом случае Харитон съест в этот день именно это мороженое.
* Если никакое мороженок не лежит в холодильнике d дней, но рейтинг мороженого дня меньше, чем рейтинг самого вкусного мороженого, которое есть у Харитона в холодильнике. В этом случае Харитон съест в этот день самое вкусное мороженое из своего холодильника. Если в холодильнике несколько порций мороженого с одинаковым рейтингом, то он съест то, которое купил последним.

Если рейтинг мороженого дня не меньше, чем рейтинг самого вкусного мороженого, хранящегося в холодильнике Харитона, и, кроме того, никакое мороженое в холодильнике не лежит уже d дней, Харитон купит две порции мороженого дня.
Одну съест, а вторую положит в холодильник.

Требуется по заданной информации о мороженых дня за n дней определить:
* Сколько раз Харитон отказывался от покупки мороженого, рейтинг которого был выше, чем хотя бы у одного мороженого, имевшегося в тот момент в холодильнике.
* Максимальное количество дней, которое порция мороженого провела в холодильнике Харитона, и количество таких порций.
* Количество сортов мороженого, порции которого пробыли в холодильнике максимальное количество дней, и вывести список этих сортов в лексикографическом (алфавитном) порядке.

#### Формат входных данных
В первой строке содержатся целые числа n,d
(1<=n<=300000, 1<=d<=100000) - количество дней, для которых имеется информация о мороженом дня, количество дней, в течение которого Харитон считает нахождение мороженого в холодильнике допустимым.

В каждой из следующих n строке содержится информация о мороженом дня в соответствующий день: наименование сорта мороженого s_j и через пробел его рейтинг r_j с точки зрения Харитона (j=1,2,...,n), (0<=r_j<=1000000)

Наименование сорта мороженого s_j - непустая строка из строчных латинских букв, цифр и нижнего подчёркивания, начинающаяся с буквы и имеющая длину не более 30 символов.

Гарантируется, что для фиксированного наименования мороженого рейтинг сорта мороженого постоянный.

#### Формат результата
В первой строке выведите целое число z - количество раз, которое Харитон отказывался от покупки мороженого, рейтинг которого был выше, чем хотя бы у одного мороженого, имевшегося в тот момент в холодильнике.

Во второй строке выведите целые числа p и q - максимальное количество дней, которое порция мороженого провела в холодильнике Харитона, и количество таких порций.

В третьей строке выведите целое число w - количество сортов, порции которых провели в холодильнике Харитона максимальное количество дней.

Далее выведите w строк - названия этих сортов в лексикографическом (алфавитном) порядке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
14 3<br>
strawberry 3<br>
vanilla 5<br>
blackberry 4<br>
banana 3<br>
strawberry 3<br>
watermelon 2<br>
lemon 6<br>
vanilla 5<br>
blackberry 4<br>
vanilla2 4<br>
strawberry 3<br>
vanilla2 4<br>
vanilla 5<br>
strawberry 3
    </td>
    <td valign='top'>
1<br>
3 2<br>
2<br>
blackberry<br>
strawberry
	</td>
  </tr>
  <tr>
    <td valign='top'>
8 4<br>
blackberry 4<br>
strawberry 3<br>
vanilla 5<br>
watermelon 2<br>
banana 3<br>
lemon 6<br>
strawberry 3<br>
vanilla 5
    </td>
    <td valign='top'>
0<br>
3 1<br>
1<br>
banana
	</td>
  </tr>
  <tr>
    <td valign='top'>
1 1<br>
blackberry 4
    </td>
    <td valign='top'>
0<br>
0 1<br>
1<br>
blackberry
	</td>
  </tr>
</tbody></table>


</details>

---

<details>
<summary>
<b>Контрольная работа (controlwork.java)</b>
</summary>
<br>

Фалалель готовится к контрольной работе.

По просьбе Фалалеля его товарищ подобрал ему n задач, для каждой из которых указал уровень сложности d_j. По мнению товарища, Фалалей в начальный момент времени способен решать задачи с уровнем сложности, не превосходящим величину f. Для краткости будем говорить, что в начальный момент времени Фалалей обладает навыком f.

Фалалей решает задачи в порядке нумерации.

Возможны следующие исходы:
* Фалалей решает задачу и уровень сложности больше текущего навыка f. В этом случае Фалалель испытывает положительные эмоции, а его навык выростает до уровня сложности задачи.
* Фалалей решает задачу и уровень сложности не больше текущего навыка f. В этом случае Фалалелю становится скучно.
* Фалалей не решает задачу. В этом случае Фалалей испытывает отрицательные эмоции. Если при этом сложность задачи не больше навыка Фалалея, то его навык уменьшается на единицу.

Ваша задача - по представленным номерам задач определить:
* минимальный и максимальный уровни сложности задачи, которую Фалалей не решил к моменту, когда он завершил работу над задачей с представленным номером;
* каких эмоций Фалалей испытал больше к моменту, когда он завершил работу над задачей с заданным номером.

#### Формат входных данных
В первой строке содержатся целые числа n,m,f
(1<= n,m <= 100000, 1 <= f<=1000000) - количество задач в наборе, количество заданных номеров задач и начальный навык Фалалея соответственно.

Во второй строке содержится n целых чисел d_1, d_2, ..., d_n (1<=d_j<=1000000, j=1,2,...,n) - уровни сложности задач.

В третьей строке содержится последовательность из n символов (без пробелов) A и R. Если на i-й позиции находится символ A, то Фалалей решил соответствующую задачу. Если R, то не решил.

В четвёртой строке содержится m целых чисел p_1, p_2, ..., p_m - номера задач, для которых нужно ответить на вопрос задачи.

#### Формат результата
Выведите m строк.
Каждая строка должна содержать два целых числа и обозначение эмоции, которую Фалалей испытывал наиболее часто к этому моменту.
Числа и обозначение эмоции должны быть разделены пробелами.

Первое и второе числа - это минимальный и максимальный уровень сложности задачи, которую Фалалей не решил к моменту завершения работы над задачей с номером p_i.
Если к этому моменту Фалалель решил все предыдущие задачи, выведите -1.

Обозначение эмоции - это последовательность символов ":-)", ":-(" для положительных и отрицательных эмоций, ":-|" для скуки.

Если Фалалей к моменту завершения работы над задачей с номером p_i испытал одинаковое (максимальное) количество различных эмоций, следует выводить обозначение той эмоции, которую он испытал позже.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
15 10 8<br>
7 5 7 8 14 6 11 7 11 12 3 11 14 12 14<br>
ARRAAARAAARRAAA<br>
7 3 14 13 9 15 8 5 3 12
    </td>
    <td valign='top'>
5 11 :-(<br>
5 7 :-(<br>
3 11 :-)<br>
3 11 :-)<br>
5 11 :-)<br>
3 11 :-|<br>
5 11 :-|<br>
5 7 :-)<br>
5 7 :-(<br>
3 11 :-(
	</td>
  </tr>
  <tr>
    <td valign='top'>
3 4 5<br>
7 3 8<br>
AAA<br>
3 2 1 3
    </td>
    <td valign='top'>
-1 -1 :-)<br>
-1 -1 :-|<br>
-1 -1 :-)<br>
-1 -1 :-)
	</td>
  </tr>
</tbody></table>


</details>

---

<details>
<summary>
<b>Подготовка (preparations.java)</b>
</summary>
<br>

Харитон расспросил однокурсников, уже сдавших экзамен, какие дополнительные вопросы задавал им преподаватель.

Всего Харитон расспросил n однокурсников, и каждый из них перечислил Харитону заданные ему дополнительные вопросы.
Для каждого дополнительного вопроса Харитон записывал тему, к которой этот вопрос относится.

Требуется выяснить, по каким темам было задано больше всего дополнительных вопросов.

#### Формат входных данных
В первой строке содержится целое число n (1<=n<=1000) - количество однокурсников, которых расспросил Харитон.

В каждой из следующих n строк содержится число m_i (0<=m_i<=1000) - количество дополнительных вопросов, на которые пришлось отвечать i-му однокурснику.
Через пробел далее записаны m_i чисел t_1,t_2,...,t_m_i (1<=t_i<=1000000) - номера тем, к которым относились эти вопросы.

#### Формат результата
В первой строке выведите целые числа p и q - количество тем, по которым было задано максимальное количество дополнительных вопросов, и количество этих вопросов.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
6<br>
3 10 5 14<br>
2 14 12<br>
5 8 13 5 12 3<br>
4 10 13 1 4<br>
0<br>
3 2 2 8
    </td>
    <td valign='top'>7 2</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Регистрация (registration.py)</b>
</summary>
<br>

Предварительно создайте текстовый файл (accounts.txt), в котором структурирована информация вида: login -> password (не менее 5 пар). При этом на каждой строчке содержатся уникальные логины, а пароли могут повторяться. Создайте функцию регистрации нового пользователя, которая будет предлагать пользователю ввести логин и пароль до тех пор, пока не будет введён уникальный логин, и пароль не будет соответствовать требованиям:
* Наличие букв в разных регистрах
* Наличие цифры
* Наличие спецсимвола (@,!,$,#)

Корректная комбинация должна быть добавлена в текстовый файл accounts.txt.

Содержимое accounts.txt на начало работы:
```
login1 -> password
user -> friendly
summer -> qwerty
qbq812309 -> gdhjasdgj
nagibator228 -> systemCall1238sj
newUser -> Hey2201#
```

</details>

---

<details>
<summary>
<b>Две кучи (two_heaps.cpp)</b>
</summary>
<br>

Имеется 2<=N<=23 камня с целочисленными весами W1, W2, ... , WN. Требуется разложить их на две кучи таким образом, чтобы разница в весе куч была минимальной. Каждый камень должен принадлежать ровно одной куче.

#### Формат входных данных
N<br>
W1 W2 ... WN

#### Формат результата
Минимальная неотрицательная разница в весе куч.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
8 9 6 9 8
    </td>
    <td valign='top'>4</td>
  </tr>
  <tr>
    <td valign='top'>
6<br>
14 2 12 9 9 8
    </td>
    <td valign='top'>2</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Польский калькулятор (calculator_polsk_prefix.cpp)</b>
</summary>
<br>

Для вычисления арифметических выражений на практике удобно использовать польскую запись. В ней операции записывают перед операндами, а не между как мы привыкли. Таким образом<br>
\- 2 1 = (2 - 1)<br>
и<br>
\- * / 15 - 7 + 1 1 3 + 2 + 1 1 = 15 / (7 - (1 + 1)) * 3 - (2 + (1 + 1))

Вам необходимо написать калькулятор, который вычисляет значение арифметического выражения в префиксной записи. Размеры операндов и результаты операций не превосходят 1000.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>+ 1 2</td>
    <td valign='top'>3</td>
  </tr>
  <tr>
    <td valign='top'>- * / 15 - 7 + 1 1 3 + 2 + 1 1</td>
    <td valign='top'>5</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Польский калькулятор (обратный) (calculator_polsk_reverse.py)</b>
</summary>
<br>

Задание связано с обратной польской нотацией. Она используется для парсинга арифметических выражений. Ещё её иногда называют постфиксной нотацией. В постфиксной нотации операнды расположены перед знаками операций.

#### Формат входных данных
В единственной строке дано выражение, записанное в обратной польской нотации. Числа и арифметические операции записаны через пробел.
На вход могут подаваться операции: +, -, *, / и числа, по модулю не превосходящие 10000.
Операция / является математическим целочисленным делением с округлением вниз.
Гарантируется, что значение промежуточных выражений в тестовых данных по модулю не больше 50000.

#### Формат результата
Выведите единственное число - значение выражения.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>3 4 +</td>
    <td valign='top'>7</td>
  </tr>
  <tr>
    <td valign='top'>12 5 /</td>
    <td valign='top'>2</td>
  </tr>
  <tr>
    <td valign='top'>-1 3 /</td>
    <td valign='top'>-1</td>
  </tr>
  <tr>
    <td valign='top'>10 2 4 * -</td>
    <td valign='top'>2</td>
  </tr>
  <tr>
    <td valign='top'>2 1 + 3 *</td>
    <td valign='top'>9</td>
  </tr>
  <tr>
    <td valign='top'>7 2 + 4 * 2 +</td>
    <td valign='top'>38</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Торговый автомат (h11_authomata.cpp)</b>
</summary>
<br>

Одна фирма обслуживает автоматы по продаже чая и кофе. Стоимость стакана чая и кофе в автомате равна пяти рублям. Автомат принимает монеты по 5 и 10 рублей, а также купюры в 10, 50 и 100 рублей. Когда покупателю надо выдавать сдачу (т.е. когда пассажир бросил в автомат десятирублёвую монету или 10-, 50- или 100- рублёвую купюру), автомат выдаёт сдачу пятирублёвыми монетами; если же покупатель бросил в автомат пятирублёвую монету, то автомат её сохраняет и может использовать для сдачи следующим покупателям. Ясно, что, чтобы обеспечить возможность выдачи сдачи всем покупателям, может потребоваться изначально загрузить в автомат некоторое количество пятирублёвых монет.

Сейчас автоматы проходят испытания с целью определить минимальное количество монет, которые надо загрузить в автомат перед началом дня.Вам дан протокол одного из таких испытаний: известен порядок, в котором покупатели оплачивали свои покупки различными монетами и купюрами.Определите, какое минимальное количество пятирублёвых монет должно было изначально находиться в автомате, чтобы всем покупателям хватило сдачи.

#### Формат входных данных
В первой строке входных данных находится одно натуральное число N — количество покупок в автомате, которые были совершены в ходе испытания 1<=N<=50000.
Во второй строке находятся N натуральных чисел, каждое из которых равно номиналу монеты или купюры, которую использовал очередной покупатель для оплаты; каждый номинал может принимать одно из четырёх значений: 5, 10, 50 или 100.

#### Формат результата
Выведите одно число — минимальное количество пятирублёвых монет, которые надо было загрузить в автомат изначально, чтобы всем покупателям хватило сдачи.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
3<br>
10 5 100</td>
    <td valign='top'>19</td>
  </tr>
  <tr>
    <td valign='top'>
3<br>
5 5 10</td>
    <td valign='top'>0</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Обратное число по модулю (h12_reciprocal.cpp)</b>
</summary>
<br>

Известно, что команда деления целых чисел на современных компьютерах исполняется неприлично долго. Оптимизирующие компиляторы во многих случаях заменяют операцию деления на константу группой операций, в которых имеется умножение на другую константу.

Для этого компилятору, в числе других действий, требуется найти такое число q для заданного делителя p, что q * p = 1 по известному модулю m.

Ваша задача по заданным числам 2 <= p,m <= 4 294 967 295 найти любое число q такое, чтобы (p * q) (mod m) = 1.

Известно также, что m — простое число, и что для заданных p и m ответ существует.

#### Формат входных данных
p m

#### Формат результата
q

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>5 7</td>
    <td valign='top'>3</td>
  </tr>
  <tr>
    <td valign='top'>199212331 4010101141</td>
    <td valign='top'>525555399</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Последовательность строк (h13_sequence.cpp)</b>
</summary>
<br>

Последовательность строк формируется следующим образом:

Первая строка состоит из цифры 1.

Каждая из последующих строк формируется из номера строки, записанного в виде последовательности десятичных цифр, за которым дописана предыдущая строка и затем перевёрнутая предыдущая строка.

Вот несколько первых строк:<br>
1<br>
211<br>
3211112<br>
432111122111123<br>
5432111122111123321111221111234<br>

Заметьте, что десятая строка начнётся с символов 10, одиннадцатая — с символов 11 и так далее.

Ваша задача заключается в том, чтобы по заданному номеру строки и номеру её элемента вывести символ, стоящий в ней на указанном месте.

#### Формат входных данных
N M<br>
P1 P2 ... PM

Ограничения:<br>
1<=N<=30<br>
1<=M<=100000<br>
1<=Pi<=length(string).

Нумерация строк и символов в строках начинается с единицы.

#### Формат результата
M символов, не разделённых пробелами, соответствующие позициям Pi.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5 5<br>
2 4 6 8 10</td>
    <td valign='top'>42112</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Перестановки (h14_permutation.cpp)</b>
</summary>
<br>

Как известно, из множества из N различных предметов можно сделать N! различных перестановок.

Если предметы можно сравнивать между собой, то перестановки можно перенумеровать в лексикографическом порядке. Например, перестановки множества {1,2,3} будут идти в следующем порядке: {1,2,3}, {1,3,2}, {2,1,3}, {2,3,1}, {3,1,2}, {3,2,1}.

Таким образом, все перестановки множества различных элементов можно пронумеровать от 1 до N!.

В нашей задаче мы будем переставлять элементы из множества натуральных чисел от 1 до N.

#### Формат входных данных
На вход программы подаётся два числа — количество предметов в перестановке 2<=N<=20 и номер перестановки 1<=M<=2*10e18.

#### Формат результата
Вывести через пробел элементы перестановки, имеющей номер M.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
120</td>
    <td valign='top'>5 4 3 2 1</td>
  </tr>
  <tr>
    <td valign='top'>
10<br>
73238</td>
    <td valign='top'>1 3 9 6 8 4 7 2 10 5</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Чуждые элементы (h15_alliens.cpp)</b>
</summary>
<br>

Последовательность из 2<=N<=1000000 элементов содержит натуральные числа от 1 до 10e18. Назовём пару соседних чисел, которая имеет общие множители, большие единицы, родственниками. В исходную последовательность вставляют натуральные числа (чуждые элементы) таким образом, что в итоговой последовательности не остаётся родственников. Требуется определить минимально возможную сумму чуждых элементов. Пример: в исходную последовательность<br>
4 8 9 10<br>
можно вставить чуждый элемент 5 после 4:<br>
4 5 8 9 10<br>
после чего последовательность не содержит родственников.

#### Формат входных данных
N<br>
X1<br>
X2<br>
...<br>
XN

#### Формат результата
Sum

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
10<br>
4<br>
8<br>
1<br>
2<br>
4<br>
2<br>
1<br>
7<br>
62<br>
3</td>
    <td valign='top'>3</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Камера хранения (h21_storeroom.cpp)</b>
</summary>
<br>

На железнодорожном вокзале столицы Бурляндии решили установить новую автоматическую камеру хранения.
Для этого потребовалось узнать, сколько ячеек одновременно занято хранящимся багажом.
Было установлено несколько датчиков использования старой камеры хранения, фиксировавших момент прихода пассажира и занятия им ячейки, а так же момент ухода пассажира и момент освобождения им ячейки.
Протокол прихода и ухода пассажиров за одни сутки приведён далее.
Ячейка не освобождается мгновенно, поэтому если в какое-то время один пассажир ушёл и в это же время пришёл другой пассажир, требуется две ячейки.
Определите максимальное количество одновременно занятых ячеек, наблюдаемое в течении суток.

Камера открыта круглосуточно. Времена прихода и ухода пассажиров находятся в пределах одних суток. В 00:00 камера хранения пуста.

#### Формат входных данных
N (количество пассажиров, 1<=N<=1000000).<br>
HA1:MA1 HD1:MD1<br>
...<br>
HAN:MAN HDN:MDN

#### Формат результата
MaximumNumberOfBusyCells

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
02:18 11:54<br>
03:18 04:16<br>
00:26 20:41<br>
17:19 20:48<br>
08:42 23:45</td>
    <td valign='top'>3</td>
  </tr>
  <tr>
    <td valign='top'>
10<br>
17:59 22:58<br>
12:25 16:06<br>
09:05 18:39<br>
08:34 23:23<br>
15:59 22:53<br>
15:55 21:20<br>
18:05 22:08<br>
03:48 22:23<br>
12:50 14:41<br>
05:46 10:41</td>
    <td valign='top'>7</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Башня (h22_circus.cpp)</b>
</summary>
<br>

В Бурляндск приехал цирк. Одним из привлекающих внимание горожан номеров всегда было построение как можно более высокой башни из группы циркачей.

В построенной башне один циркач стоит на земле, второй - на его плечах, третий - на плечах второго, и так далее.
У циркача под номером i вес равен wi, а сила — fi.
Сила — способность удерживать на себе заданный вес.
Точно известно, что более тяжёлый циркач является и более сильным.
Впрочем, циркачи с одинаковым весом могут иметь различную силу.

#### Формат входных данных
Первая строка ввода содержит 4<=N<=3000 — количество человек в команде, которые хотят построить башню.

Каждая их последующих строк содержит по два числа — вес и силу участника команды. Все числа — положительные целые, меньшие 10000.

#### Формат результата
Максимальная высота башни, которую может построить эта команда.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
1 9<br>
5 13<br>
13 15<br>
16 20</td>
    <td valign='top'>4</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Разрезание блинов (h23_cakes.cpp)</b>
</summary>
<br>

На очень большом столе разложено много абсолютно круглых блинов, некоторые из которых могут частично или полностью налегать друг на друга.
Абсолютно прямым ножом проводится луч из первой точки по направлению ко второй.
Требуется определить, какие из блинов будут задеты разрезом. Касания НЕ учитываются.

#### Формат входных данных
В первой строке — координаты двух точек на плоскости, которые определяют луч разреза.
Во второй строке — количество блинов 1<=N<=100000.
В следующих N строках по три числа — координаты центра блина и его радиус.
Все координаты — целые числа от -10000 до 10000.

Радиус — строго положительное целое число.

#### Формат результата
Номера разрезанных блинов в порядке возрастания. Нумерация блинов начинается с 1.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
0 0 0 1<br>
5<br>
-1 -1 1<br>
-2 -2 1<br>
-3 -3 4<br>
1 2 4<br>
3 1 1</td>
    <td valign='top'>4</td>
  </tr>
  <tr>
    <td valign='top'>
0 0 0 1<br>
2<br>
3 0 3<br>
3 0 1</td>
    <td valign='top'></td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Позитивизм (h24_positivism.cpp)</b>
</summary>
<br>

У Иеремии родители — философы. Он часто слышит их разговоры, но мало что в них понимает. Сам Иеремия учится в информатическом классе физматшколы, и философия его пока не интересует.
Недавно он услышал новое для себя слово: позитивизм. Он постеснялся спросить своих родителей, что это слово обозначает, и узнал в Википедии, что-то про эмпирические и философские исследования.
Так как слово ему понравилось, он загорелся идеей провести какие-то исследования, а так, как недавно в школе они проходили матрицы, вопрос, что же будет объектом исследования, оказался для него очевидным.
Он называет позитивной матрицей такую двумерную матрицу, у которой сумма элементов каждой из строк неотрицательна и сумма элементов каждого из столбцов тоже неотрицательна.

Он поставил перед собой задачу установить, каждую ли из матриц можно сделать позитивной, имея ровно две операции: смену всех знаков на противоположные либо для всех элементов строки, либо для всех элементов столбца.
Операции первого вида он записывал, как l y, где y — номер инвертируемой строки, а второго — как c x, где x — номер инвертируемого столбца. И столбцы и строки нумеруются с нуля.
Он проделал серию экспериментов и убедился, что если решение существует, то оно может быть не единственным.

Ваша задача состоит в том, чтобы помочь Иеремии, написав программу, которая либо сообщит, что не существует такой последовательности операций, чтобы матрица стала позитивной, либо выдаст любую последовательность операций, приводящую в конечном итоге к позитивной матрице.

#### Формат входных данных
В первой строке — числа N и M — количество строк и столбцов соответственно. Эти числа не превосходят 100.
В каждой из следующих N строк содержатся значения элементов каждой строки. Ни одно из этих чисел по абсолютной величине не превосходит 10e6.

#### Формат результата
Если матрицу можно сделать позитивной, то решение должно состоять из произвольного числа строк указанного выше вида. Если матрица позитивна с самого начала, программа ничего не должна выводить.
Если её позитивной сделать нельзя, нужно вывести одно слово: Impossible.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
3 3<br>
1 -10 8<br>
2 1   3<br>
1 7   4</td>
    <td valign='top'>
l 0<br>
c 2</td>
  </tr>
  <tr>
    <td valign='top'>
2 2<br>
1 2<br>
3 4</td>
    <td valign='top'></td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Количество подстрок (h25_strings.cpp)</b>
</summary>
<br>

Назовём подстрокой любой набор подряд идущих символов строки. Например, в строке aba можно найти три подстроки длины один: a, b, a, две подстроки длины два: ab и ba, а также одну подстроку длины 3: aba.
Две подстроки здесь совпадают, поэтому различных подстрок здесь 5.
Нужно для заданной строки, состоящей из строчных букв латинского алфавита, определить, сколько в ней можно найти различных подстрок.

#### Формат входных данных
Строка, длиной от 5 до 10000 символов.

#### Формат результата
Количество различных подстрок в данной строке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>abracadabra</td>
    <td valign='top'>54</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Генератор Гауссовых слов (gausswordgenerator.py)</b>
</summary>
<br>

Гауссово слово – это слово, в котором все буквы встречаются ровно два раза. При этом вначале идет буква a, первая непарная ей – b, следующая непарная им – с, и так далее.
Требуется написать программу, которая выведет все Гауссовы слова из букв от "a" вплоть до введённой латинской буквы.

#### Формат входных данных
Одна буква латинского алфавита.

#### Формат результата
Все возможные Гауссовы слова из заданного диапазона букв по одному слову на строчке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>a</td>
    <td valign='top'>aa</td>
  </tr>
  <tr>
    <td valign='top'>c</td>
    <td valign='top'>
aabbcc<br>
aabcbc<br>
aabccb<br>
ababcc<br>
abbacc<br>
abbcac<br>
abbcca<br>
abacbc<br>
abcabc<br>
abcbac<br>
abcbca<br>
abaccb<br>
abcacb<br>
abccab<br>
abccba</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Накачка и сброс (pumpndump.py)</b>
</summary>
<br>

Pump'n'dump (накачка и сброс) - это схема относительно честного отъема денег. Она выглядит следуюшим образом. Несколько крупных игроков или много мелких договариваются вместе купить малоизвестную бумагу с низкой ценой и объёмом торгов. Это приводит к мгновенному взлету цены (pump), далее приходят неопытные игроки в надежде успеть заработать на таком росте. В этот момент организаторы схемы начнают все продавать (dump). Весь процесс занимает от нескольких минут до нескольких часов.

Ваша задача найти самый сильный pump'n'dump бумаги на заданном промежутке времени. Для этого для каждого дня определим число pnd, равное отношению максимальной цены бумаги в данный день к максимуму из цен открытия и закрытия в тот же день. Нужно найти день, когда pnd был максимален и его величину.

#### Формат входных данных
На вход подаётся много-много строк в формате дата цена.
Самая первая цена за день - цена открытия.
Самая последняя цена за день - цена закрытия.
Гарантируется, что цены идут в хронологическом порядке.
 
#### Формат результата
Выведите самое большое число pnd

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
2020-07-19 18:00:00 20<br>
2020-07-19 19:00:00 10<br>
2020-07-19 20:00:00 30<br>
2020-07-19 21:00:00 40<br></td>
    <td valign='top'>1</td>
  </tr>
  <tr>
    <td valign='top'>
2020-07-19 21:00:00 20<br>
2020-07-19 22:00:00 10<br>
2020-07-19 23:00:00 40<br>
2020-07-20 00:00:00 50<br>
2020-07-20 01:00:00 10<br>
2020-07-20 02:00:00 20<br>
2020-07-20 03:00:00 15<br>
2020-07-20 04:00:00 60<br>
2020-07-20 05:00:00 10</td>
    <td valign='top'>1.2</td>
  </tr>
  <tr>
<td valign='top'>
2021-03-01 09:30:00 690<br>
2021-03-01 10:30:00 703<br>
2021-03-01 11:30:00 711<br>
2021-03-01 12:30:00 714<br>
2021-03-01 13:30:00 709<br>
2021-03-01 14:30:00 710<br>
2021-03-01 15:30:00 712<br>
2021-03-02 09:30:00 719<br>
2021-03-02 10:30:00 709<br>
2021-03-02 11:30:00 705<br>
2021-03-02 12:30:00 704<br>
2021-03-02 13:30:00 699<br>
2021-03-02 14:30:00 691<br>
2021-03-02 15:30:00 686<br>
2021-03-03 09:30:00 690<br>
2021-03-03 10:30:00 679<br>
2021-03-03 11:30:00 693<br>
2021-03-03 12:30:00 680<br>
2021-03-03 13:30:00 680<br>
2021-03-03 14:30:00 666<br>
2021-03-03 15:30:00 657<br></td>
    <td valign='top'>1.0043478260869565</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Кубики (cubes.py)</b>
</summary>
<br>

Аня и Боря любят играть в разноцветные кубики, причем у каждого из них свой набор и в каждом наборе все кубики различны по цвету. Однажды дети заинтересовались, сколько существуют цветов таких, что кубики каждого цвета присутствуют в обоих наборах. Для этого они занумеровали все цвета случайными числами. На этом их энтузиазм иссяк, поэтому вам предлагается помочь им в оставшейся части. Номер любого цвета — это целое число в пределах от 0 до 109.

#### Формат входных данных
В первой строке входного файла записаны числа N и M — количество кубиков у Ани и Бори соответственно. В следующих N строках заданы номера цветов кубиков Ани. В последних M строках номера цветов кубиков Бори.
 
#### Формат результата
Выведите сначала количество, а затем отсортированные по возрастанию номера цветов таких, что кубики каждого цвета есть в обоих наборах, затем количество и отсортированные по возрастанию номера остальных цветов у Ани, потом количество и отсортированные по возрастанию номера остальных цветов у Бори.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
4 3<br>
0<br>
1<br>
10<br>
9<br>
1<br>
3<br>
0</td>
    <td valign='top'>
2<br>
0 1<br>
2<br>
9 10<br>
1<br>
3</td>
  </tr>
  <tr>
    <td valign='top'>
2 2<br>
1<br>
2<br>
2<br>
3</td>
    <td valign='top'>
1<br>
2<br>
1<br>
1<br>
1<br>
3</td>
  </tr>
  <tr>
    <td valign='top'>0 0</td>
    <td valign='top'>
0<br>
0<br>
0</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Продажи (sales.py)</b>
</summary>
<br>

Дана база данных о продажах некоторого интернет-магазина. Каждая строка входного файла представляет собой запись вида Покупатель товар количество, где Покупатель — имя покупателя (строка без пробелов), товар — название товара (строка без пробелов), количество — количество приобретенных единиц товара. Создайте список всех покупателей, а для каждого покупателя подсчитайте количество приобретенных им единиц каждого вида товаров.

#### Формат входных данных
Вводятся сведения о покупках в указанном формате.
 
#### Формат результата
Выведите список всех покупателей в лексикографическом порядке, после имени каждого покупателя выведите двоеточие, затем выведите список названий всех приобретенных данным покупателем товаров в лексикографическом порядке, после названия каждого товара выведите количество единиц товара, приобретенных данным покупателем. Информация о каждом товаре выводится в отдельной строке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
Ivanov paper 10<br>
Petrov pens 5<br>
Ivanov marker 3<br>
Ivanov paper 7<br>
Petrov envelope 20<br>
Ivanov envelope 5</td>
    <td valign='top'>
Ivanov:<br>
envelope 5<br>
marker 3<br>
paper 17<br>
Petrov:<br>
envelope 20<br>
pens 5</td>
  </tr>
  <tr>
    <td valign='top'>
Ivanov aaa 1<br>
Petrov aaa 2<br>
Sidorov aaa 3<br>
Ivanov aaa 6<br>
Petrov aaa 7<br>
Sidorov aaa 8<br>
Ivanov bbb 3<br>
Petrov bbb 7<br>
Sidorov aaa 345<br>
Ivanov ccc 45<br>
Petrov ddd 34<br>
Ziborov eee 234<br>
Ivanov aaa 45</td>
    <td valign='top'>
Ivanov:<br>
aaa 52<br>
bbb 3<br>
ccc 45<br>
Petrov:<br>
aaa 9<br>
bbb 7<br>
ddd 34<br>
Sidorov:<br>
aaa 356<br>
Ziborov:<br>
eee 234</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Слишком серьёзная задача (tooserious.py)</b>
</summary>
<br>

Эконом прослушал курс по финансовым рынкам. Он показался ему слишком практическим. Теперь надо как-то применять знания на практике. Поэтому все скачали себе Пенькоф-Инвестиции и начали торговать. Это не является инвестиционной рекомендацией.
Давайте немного помечтаем и представим, что нам стало так везти, что для любой ценной бумаги в любой день мы умудряемся купить её по минимальной цене и в тот же день продать по максимальной.
Страшно подумать, как можно было бы приумножить свой капитал всего лишь за несколько дней...

Ваша задача - узнать во сколько раз вырастут ваши вложения при такой удаче. Все заработанные деньги вы реинвестируете. Короткие позиции запрещены. Продавать раньше, чем покупать запрещено. У вас нет премиум-аккаунта.

#### Формат входных данных
На вход подаётся много-много строк в формате дата цена. Гарантируетcя, что цена изменяется от 0 до 106.

#### Формат результата
Выведите свою максимальную доходность. В процентах. Сумма, которую вы изначально вкладываете в бумагу - неважна.

#### Комментарий к примерам
1. Есть 100 рублей. Мы купили бумаги по 10 и продали по 40. В итоге у нас 400 рублей. Итоговая доходность 100*(40 - 10)/10 = 300%
2. Есть 100 рублей. Мы купили бумаги по 20 и продали по 40. Ко второму дню у нас есть 200 рублей. Все полученные деньги мы реинвестировали. Купили за 20, продали за 60. В итоге у нас 600 рублей. Итоговая доходность 500%.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
2020-07-19 18:00:00 20<br>
2020-07-19 19:00:00 10<br>
2020-07-19 20:00:00 30<br>
2020-07-19 21:00:00 40</td>
    <td valign='top'>300</td>
  </tr>
  <tr>
    <td valign='top'>
2020-07-19 21:00:00 20<br>
2020-07-19 22:00:00 40<br>
2020-07-19 23:00:00 10<br>
2020-07-20 00:00:00 20<br>
2020-07-20 01:00:00 60<br>
2020-07-20 02:00:00 30</td>
    <td valign='top'>500</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Очень быстрая сортировка (radix_sort.cpp)</b>
</summary>
<br>

Уметь сортировать быстро – полезный навык. Стандартные сортировки в языках Си и C++ достаточно быстры и универсальны. К сожалению, их универсальность имеет недостаток: сложность алоритмов этих сортировки составляет O(N log(N)).
Между тем известно, что для некоторых типов данных имеются и сортировки со сложность по времени O(N).
Вам и предстоит такую написать.

Файл, который вы должны послать в тестирующую систему, должен иметь реализацию ровно одной функции. Она должна ничего не вводить и ничего не выводить.
```
void fast_sort(unsigned *begin, unsigned *end) {
    // Your code for implementation
}
```
Требуется, чтобы ваша функция отсортировала массив, заданный аргументами, по возрастанию.
Ваша программа не должна содержать функции main.

#### Пример
Пример программы, которую можно использовать при тестировании:
```
int main() {
    unsigned array[8] = {3,1,4,1,5,9,2,6};
    fast_sort(array, array+8);
    // Now array = {1,1,2,3,4,5,6,9}
}
```

</details>

---

<details>
<summary>
<b>Факториальная система счисления (r11_factradix.cpp)</b>
</summary>
<br>

Наряду с уже привычными позиционными системами счисления, к которым мы все уже привыкли, существует множество других, всё также позиционных, но с другими правилами вычисления весов позиций.
Мы рассмотрим факториальную систему счисления, в которой вес каждой позиции — факториал от её номера. Для позиций после десятичной точки используются обратные к факториалам веса.
Каждая правильная дробь (p < q) представляется в такой системе единственным конечным образом при условии, что в самом правом члене записи коэффициент отличен от нуля.
Ваша задача — найти такие числа ai < i, чтобы сумма их произведений на факториалы их индексов i равнялась заданной дроби.

#### Формат входных данных
1 <= P < Q < 1000

#### Формат результата
В одной строке через пробел выведите коэффициенты разложения, начиная с a2.

Гарантируется, что число выводимых членов будет меньше 1000.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>1 4</td>
    <td valign='top'>0 1 2</td>
  </tr>
  <tr>
    <td valign='top'>5 7</td>
    <td valign='top'>1 1 1 0 4 2</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Танец точек (r12_dance.cpp)</b>
</summary>
<br>

На прямой располагается 1<=N<=10000 точек с целочисленными координатами −10e9<=Vi<=10e9.
Каждой из точек разрешается сделать ровно одно движение (танцевальное па) в любом направлении на расстояние не больше 0<=L<=10e8 и остановиться на другой позиции.
Какое минимальное количество точек может оказаться после окончания танца (все точки после танца, оказывающиеся на одной позиции сливаются в одну)?

#### Формат входных данных
L N<br>
V1<br>
V2<br>
...<br>
VN

#### Формат результата
MinimalNumberOfPoints

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
10 5<br>
30 3 14 19 21</td>
    <td valign='top'>2</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Офисное здание (r13_complaints.cpp)</b>
</summary>
<br>

Эта задача аналогична задаче h21_storeroom за исключением точности до секунд.

В одной очень большой стране в одном очень большом городе стояло очень-очень большое здание, в котором граждане этой страны подавали жалобы на других граждан. Так как жалобщиков было очень много, оно работало круглосуточно, но каждый из посетителей, пришедших в какое-то время после нуля часов, был обязан покинуть здание до 24 часов.
Клерков, принимающих жалобы, было не очень много, из-за чего гражданам приходилось сидеть и ждать в очереди, пока нужный клерк освободится.
На эту организацию, принимающую жалобы, в неё же поступила жалоба, что жалобы рассматриваются недостаточно быстро и вам было поручено определить, а сколько же жалобщиков одновременно находится в здании. К счастью для вас, во всех жителей этой страны были встроены чипы, точно определяющие положение в любой момент времени.
Вам был дан доступ к данным за сутки. В 00:00:00 здание жалобщиков не ещё не содержало, а в 24:00:00 уже не содержало, так как все жалующиеся покинули здание. Дверей в здании много, поэтому вполне могли случаться такие ситуации, когда в одну и ту же секунду один жалобщик прибывал, а другой — покидал помещение. В таком случае оба считались находящимися в здании.
Ваша задача — определить максимальное число жалобщиков, одновременно находящихся в здании.

#### Формат входных данных
На вход программы подаётся число 1<=N<=200000 — число записей в базе данных. Каждая запись имеет содержит два времени с точностью до секунд — время прибытия и время убытия в формате HH:MM:SS.

#### Формат результата
Одно число — максимальное количество жалобщиков, одновременно находящихся в здании.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
02:03:42 20:44:18<br>
02:01:25 13:54:01<br>
13:04:48 23:39:34<br>
02:08:16 19:30:44<br>
01:02:34 08:00:07</td>
    <td valign='top'>4</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Подмножества (r14_subsets.cpp)</b>
</summary>
<br>

Множество задано строкой, то есть каждая буква есть элемент множества.
Но это множество — не совсем простое. Элементы в нём могут повторяться.
Два подмножества считаются одинаковыми, если все элементы одного множества совпадают с элементами другого. Например, множества, представленные строками abc и cba совпадают. Совпадают также множества abra и raba.
Ваша задача по заданной строке, представляющей исходное множество, вывести все различные его подмножества, каждое на отдельной строке вывода. Выводить можно в произвольном порядке. Выход не должен содержать совпадающие подмножества.
Пустое множество тоже является подмножеством исходного.

#### Формат входных данных
Исходное множество в виде строки

#### Формат результата
Все уникальные подмножества исходного множества по одному на строку. Подмножества не требуется как-либо упорядочивать, будет принят любой верный ответ.

Не забудьте, что пустая строка — тоже верное подмножество. В приведённом примере она следует первой, перед строкой a.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>abra</td>
    <td valign='top'>
<br>
a<br>
b<br>
ba<br>
ar<br>
rb<br>
aa<br>
raab<br>
baa<br>
abr<br>
ara<br>
r</td>
  </tr>
  <tr>
    <td valign='top'>
<br></td>
    <td valign='top'>
<br></td>
  </tr>
  <tr>
    <td valign='top'>Q1aQQ</td>
    <td valign='top'>
QQa<br>
Qa<br>
1<br>
QQ<br>
1a<br>
QQQa<br>
QQQ<br>
1QQQ<br>
a<br>
1Q<br>
1QQ<br>
<br>
1QQQa<br>
1QQa<br>
Q<br>
1Qa</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Игра в 2048 (game2048.cpp)</b>
</summary>
<br>

Петя решил поиграть в известную игру 2048. Но играть в классическую версию ему уже неинтересно и он разработал улучшенную версию. У игрока имеется набор из нескольких чисел, где каждое число - степень двойки с натуральным показателем, не превыщающим n. Каждый ход игрок может сделать одно из следующих действий:

Сгенерировать число 2^k, это действие занимает ak секунд.

Умножить все имеющиеся числа на 2. При этом, если вы умножаете на 2 число 2^n, оно превращается в число 2. Такое действие занимает x секунд.

Например, если вы собрали набор 2, 32, 128 и n=7, то после выполнения второго действия у вас будет набор 4, 64, 2.
Игра заканчивается, когда вы собираете ровно n чисел, и все они различны. Изначально у игрока нет чисел. Все ходы выполняются последовательно, один за одним.
Петя решил провести соревнования по новой игре, и вы принимаете в нём участие. Спланируйте свою тактику так, чтобы быстрее всего закончить игру.

#### Формат входных данных
В первой строке даны два натуральных числа n (2<=n<=2000) и x (1<=x<=10e9) - требуемое количество чисел и время работы умножителя.
Во второй строке задано n целых чисел ai (1<=ai<=10e9) - время генерации числа 2^i.

#### Формат результата
Выведите одно число - минимальное количество времени, необходимое для прохождения игры.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
3 5<br>
1 2 3</td>
    <td valign='top'>6</td>
  </tr>
  <tr>
    <td valign='top'>
4 5<br>
1 100 3 4</td>
    <td valign='top'>13</td>
  </tr>
</tbody></table>

#### Замечание
В первом тесте невыгодно использовать второе действие, поэтому просто последовательно сгенерируем все степени двойки.
Во втором тесте выгодно сгенерировать за первые два хода (2,8), после этого умножить их на два, получить набор (4,16), и за два хода сгенерировать 2 и 8. Ответ: 1+3+5+1+3=13.

</details>

---

<details>
<summary>
<b>Несколько классов (several_classes.cpp)</b>
</summary>
<br>

Разработать набор классов, объекты которых реализуют типы данных, указанные ниже.
С помощью перегрузки операторов (operator) разработать стандартную арифметику объектов, включающую арифметические действия над объектами и стандартными типами (целыми, вещественными, строками – в зависимости от вида объектов), присваивание, ввод и вывод в стандартные потоки (используя операторы «<<» и «>>»), приведение к/от базового типа данных.
Организовать операции в виде конвейера значений, с результатом (новым объектом) и сохранением значений входных операндов.

1. Дата и время, представленные целочисленными переменными: год, месяц, день, час, минута, секунда.
Базовый тип: uint64_t формат представления unix time.
Реализовать возможность преобразования в/из формата представления filetime (целое 64-х разрядное значение, представляющее число интервалов по 100 наносекунд, прошедших с первого января 1601 года).

2. Год «от Адама», имеющий внутреннее представление в виде целочисленных переменных: индикт, круг солнцу, круг луне. Диапазоны значений (циклические): индикт 1—15, круг солнцу 1—28, круг луне 1—19. Ежегодно каждая переменная увеличивается на 1. Итоговое значение вычисляется как произведение переменных (диапазона на некоторый множитель; переменные независимы), а хранимое значение является остатком от деления (на диапазон), при этом 0 соответствует максимум.
Необходима возможность отображения/задания как в виде одного числа, так и виде трех.
Реализовать возможность преобразования в/из формата представления «от рождества Христова» используя соответствие 1652 = 7160 «от Адама».

3. Разреженная матрица, представленная динамическим массивом структур, содержащих описания ненулевых коэффициентов: индексы местоположения коэффициента в матрице (целые) и значение коэффициента (вещественное).

</details>

---

<details>
<summary>
<b>Агата и Кристи (agata_kristie.cpp)</b>
</summary>
<br>

Кристи и Агата – лучшие подруги. Они любят проводить свободное время за разгадыванием головоломок. В этот раз загадку подготовила Кристи, помогите Агате справиться с задачей. Даны n чисел ai (1 <= ai <= 200000). Также имеются q запросов вида (lj , rj) – такой запрос означает, что надо сложить все числа на отрезке от lj до rj включительно и вернуть полученную сумму. Кристи дала Агате набор чисел и сами запросы. Задача Агаты – расставить числа ai на позициях от 1 до n (по одному на позицию) так, чтобы сумма ответов на все q запросов была как можно больше. Помогите Агате!

#### Формат входных данных
В первой строке через пробел даны количество чисел в наборе – n (1 <= n <= 200000) и количество запросов q (1 <= q <= 200000). Во второй строке даны числа ai (1 <= ai <= 200000), записанные через пробел. В следующих q строках даны запросы по одному в строке. Запрос j состоит из двух чисел lj и rj , записанных через пробел (1 <= lj <= rj <= n).

#### Формат результата
Выведите единственное число – максимальную сумму ответов на запросы, которую может получить Агата.

#### Примеры 
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5 3<br>
1 9 4 3 1<br>
1 4<br>
2 2<br>
3 5</td>
    <td valign='top'>34</td>
  </tr>
  <tr>
    <td valign='top'>
1 1<br>
5<br>
1 1</td>
    <td valign='top'>5</td>
  </tr>
  <tr>
    <td valign='top'>
2 2<br>
8 4<br>
1 1<br>
2 2<br>
1 1</td>
    <td valign='top'>12</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Физрук Арсений (gym_teacher.cpp)</b>
</summary>
<br>

В начале урока физкультуры ученики 13А класса выстроились в ряд. Физрук Арсений любит порядок, но школьники опять встали не по росту. Он решил проучить их и выбрать какой-то хороший отрезок детей, и отправить их играть в волейбол, а остальных оставить выполнять нормативы. Хорошим отрезком детей Арсений называет такой непрерывный отрезок детей в ряду, что их рост строго убывает. Ученики любят волейбол, поэтому хотят понять, есть ли у них шанс оказаться в числе счастливчиков. Для этого каждый школьник хочет выяснить, как много людей может пойти играть с ним в волейбол, то есть найти длину наибольшего хорошего отрезка, содержащего его самого.

#### Формат входных данных
Первая строка содержит одно целое число n (1 <= n <= 100000) — количество учеников 13А, пришедших на урок.
Вторая строка содержит n целых чисел a1, a2, ..., an (1 <= ai <= 1000000000) — рост школьников в том порядке, в котором они встали изначально.

#### Формат результата
Выведите n целых чисел через пробел, где i-е число — максимальная длина хорошего отрезка, содержащего школьника номер i.

Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
7 4 2 2 10</td>
    <td valign='top'>3 3 3 1 1</td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
2 4 6 4 2</td>
    <td valign='top'>1 1 3 3 3</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Гурман (gourmet.cpp)</b>
</summary>
<br>

Нитуширг в жизни больше всего любит две вещи - вкусно поесть и отдыхать на море. Поэтому он решил совместить приятное с приятным и поехать на пятизвёздочный морской курорт Фокьнит. Но вот незадача: в Фокьните есть только одна столовая, меню в которой каждый день заранее фиксировано. Поскольку Нитуширг - гурман, он предпочитает разнообразие в еде, поэтому если за время отдыха какое-то меню попадётся более K раз - Нитуширг очень расстроится и весь отпуск пойдёт насмарку. При этом, разумеется, Нитуширг хочет отдохнуть на море как можно дольше. Ваша задача состоит в том, чтобы по известному заранее меню столовой на N дней выбрать как можно более длинный отрезок подряд идущих дней, в которые Нитуширг поедет в Фокьнит так, чтобы никакой набор блюд не повторялся более K раз за всё время поездки.

#### Формат входных данных
В первой строке вам даны целые числа 1 <= N <= 100000 и 1 <= K <= N - количество дней, когда Фокьнит открыт для гостей и K - максимальное количество раз, которое может повториться меню за время отпуска. В следующей строке входного файла вам дана строка, состоящая из N строчных латинских букв. Каждая буква означает свой вариант меню, разным меню соответствуют разные буквы.

#### Формат результата
На выход ваша программа должна вывести два целых числа: 1 <= L <= N - максимальное количество дней отпуска Нитуширга и 1 <= d0 <= N - номер дня заезда. Считайте, что в день заезда Нитуширг успевает съесть предлагаемое столовой меню.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
1 1<br>
a</td>
    <td valign='top'>1 1</td>
  </tr>
  <tr>
    <td valign='top'>
6 2<br>
abbbaa</td>
    <td valign='top'>4 3</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Структура данных - Дек (data_structure_deck.py)</b>
</summary>
<br>

Гоша реализовал структуру данных Дек, максимальный размер которого определяется заданным числом. Методы push_back(x), push_front(x), pop_back(), pop_front() работали корректно. Но, если в деке было много элементов, программа работала очень долго. Дело в том, что не все операции выполнялись за О(1). Помогите Гоше! Напишите эффективную реализацию. При реализации нельзя использовать связный список.

#### Формат входных данных
В первой строке записано количество команд n - целое число, не превосходящее 5000. Во второй строке записано число m - максимальный размер дека. Он не превосходит 1000. В следующих n строках записана одна из команд:
* push_back(value) - добавить элемент в конец дека. Если в деке уже находится максимальное число элементов, вывести 'error'.
* push_front(value) - добавить элемент в начало дека. Если в деке уже находится максимальное число элементов, вывести 'error'.
* pop_back() - вывести последний элемент дека и удалить его. Если дек был пуст, то вывести 'error'.
* pop_front() - вывести первый элемент дека и удалить его. Если дек был пуст, то вывести 'error'.
value - целое число, по модулю не превосходящее 1000.

#### Формат результата
Выведите результат выполнения кадой команды на отдельной строке. Для успешных запросов push_back(x) и push_front(x) ничего выводить не надо.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
4<br>
push_front 861<br>
push_front -819<br>
pop_back<br>
pop_back</td>
    <td valign='top'>861<br>
-819</td>
  </tr>
  <tr>
    <td valign='top'>
7<br>
10<br>
push_front -855<br>
push_front 720<br>
pop_back<br>
pop_back<br>
push_back 844<br>
pop_back<br>
push_back 823</td>
    <td valign='top'>
-855<br>
720<br>
844</td></tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Сжиматель фоток (BMP_image_resizer/BMP_image_resizer.cpp)</b>
</summary>
<br>

В файле pic.bmp задано изображение в формате True Color 32 бита на пиксел. Написать программу на языке C++, которая загружает это изображение в программу, масштабирует изображение таким образом, чтобы его ширина и высота уменьшились бы втрое и выводит в файл pic2.bmp.
В каждой точке создаваемого изображения каждая компонента цвета должна быть выбрана в виде среднего значения из девяти значений из квадрата 3х3 вокруг соответствующей точки на исходном изображении. В граничных точках размер области вокруг соответствующей точки на исходном изображении может быть меньше.
Вся отведенная память в программе должна быть очищена. Все открытые файлы должны быть закрыты.


</details>

---

<details>
<summary>
<b>Скобочная последовательность (bracketssequence.py)</b>
</summary>
<br>

Дана скобочная последовательность. Нужно определить, правильная ли она.
Будем придерживаться такого определения:
* пустая строка - правильная скобочная последовательность;
* правильная скобочная последовательность, взятая в скобки одного типа является правильной скобочной последовательностью;
* правильная скобочная последовательность с приписанной слева или справа правильной скобочной последовательностью - тоже правильная.

На вход подаётся последовательность из скобок трёх видов: [], (), {}.
Напишите функцию is_correct_bracket_seq, которая принимает на вход скобочную последовательность и возвращает True, если последовательность правильная, а иначе False.

#### Формат входных данных
На вход подаётся одна строка, содержащая скобочную последовательность. Скобки записаны подряд, без пробелов.

#### Формат результата
Выведите True или False

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>{[()]}</td>
    <td valign='top'>True</td>
  </tr>
  <tr>
    <td valign='top'>()</td>
    <td valign='top'>True</td>
  </tr>
  <tr>
    <td valign='top'>({)}</td>
    <td valign='top'>False</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Списочная очередь (listqueue.py)</b>
</summary>
<br>

Любимый вариант очереди Тимофея - очередь, написанная с использованием связного списка. Помогите ему с реализацией. Очередь должна поддерживать выполнение трёх команд:
* get() - вывести элемент, находящийся в голове очереди, и удалить его. Если очередь пуста, то вывести "error";
* put(x) - добавить число x в очередь;
* size() - вывести текущий размер очереди.

#### Формат ввода
В первой строке записано количество команд n - целое число, не превосходящее 1000. В каждой из следующих n строк записаны команды по одной строке.

#### Формат вывода
Напечатайте результаты выполнения нужных команд, по одному на строке.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
10<br>
put -34<br>
put -23<br>
get<br>
size<br>
get<br>
size<br>
get<br>
get<br>
put 80<br>
size</td>
    <td valign='top'>
-34<br>
1<br>
-23<br>
0<br>
error<br>
error<br>
1</td>
  </tr>
  <tr>
    <td valign='top'>
6<br>
put -66<br>
put 98<br>
size<br>
size<br>
get<br>
get</td>
    <td valign='top'>
2<br>
2<br>
-66<br>
98</td>
  </tr>
  <tr>
    <td valign='top'>
9<br>
get<br>
size<br>
put 74<br>
get<br>
size<br>
put 90<br>
size<br>
size<br>
size</td>
    <td valign='top'>
error<br>
0<br>
74<br>
0<br>
1<br>
1<br>
1</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Ограниченная очередь (sizedqueue.py)</b>
</summary>
<br>

Нужно написать класс MyQueueSized, который принимает параметр max_size, означающий максимально допустимое количество элементов в очереди.
Реализуйте программу, которая будет эмулировать работу такой очереди.
Функции, которые надо реализовать, описаны в формате ввода.

#### Формат входный данных
В первой строке записано одно число - количество команд, оно не превосходит 5000. Во второй строке задан максимально допустимый размер очереди, он не превосходит 5000. Далее идут команды по одной на строке. Команды могут быть следующих видов:
* push(x) - добавить число x в очередь;
* pop() - удалить число из очереди и вывести на печать;
* peek() - напечатать первое число в очереди;
* size() - вернуть размер очереди.

При превышении допустимого размера очереди нужно вывести "error". При вызове операций pop() или peek() для пустой очереди нужно вывести "None".

#### Формат результата
Напечатайте результаты выполнения нужных команд, по одному на строке.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
8<br>
2<br>
peek<br>
push 5<br>
push 2<br>
peek<br>
size<br>
size<br>
push 1<br>
size</td>
    <td valign='top'>
None<br>
5<br>
2<br>
2<br>
error<br>
2</td>
  </tr>
  <tr>
    <td valign='top'>
10<br>
1<br>
push 1<br>
size<br>
push 3<br>
size<br>
push 1<br>
pop<br>
push 1<br>
pop<br>
push 3<br>
push 3</td>
    <td valign='top'>
1<br>
error<br>
1<br>
error<br>
1<br>
1<br>
error</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Стек (stack.py)</b>
</summary>
<br>

Нужно реализовать класс StackMax, который поддерживает операцию определения максимума среди всех элементов в стеке. Класс должен поддерживать операции push(x), где x - целое число, pop() и get_max().

#### Формат входных данных
В первой строке записано одно число n - количество команд, которое не превосходит 10000. В следующих n строках идут команды. Команды могут быть следующих видов:
* push(x) - обавить число x в стек;
* pop() - удалить число с вершины стека;
* get_max() - напечатать максимальное число в стеке

Если стек пуст, при вызове команды get_max() нужно напечатать "None", для команды pop() - "error".

#### Формат результата
Для каждой команды get_max() напечатайте результат её выполнения. Если стек пустой, для команды get_max() напечатайте "None". Если происходит удаление из пустого стека - напечатайте "error".

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
8<br>
get_max<br>
push 7<br>
pop<br>
push -2<br>
push -1<br>
pop<br>
get_max<br>
get_max</td>
    <td valign='top'>
None<br>
-2<br>
-2</td>
  </tr>
  <tr>
    <td valign='top'>
7<br>
get_max<br>
pop<br>
pop<br>
pop<br>
push 10<br>
get_max<br>
push -9</td>
    <td valign='top'>
None<br>
error<br>
error<br>
error<br>
10</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Транспонирование матрицы (transposeMatrix.py)</b>
</summary>
<br>

Есть матрица размера m x n. Нужно написать функцию, которая её транспонирует. Транспонированная матрица получается из исходной заменой строк на столбцы.

#### Формат входных данных
В первой строке задано число m - количество строк матрицы.
Во второй строке задано n - число столбцов.
m,n<=1000

В следующих m строках задана матрица. Числа в ней не превосходят по модулю 1000.

#### Формат результата
Напечатайте транспонированную матрицу в том же формате, который задан во входных данных. Каждая строка матрицы выводится на отдельной строке, элементы разделяются пробелами.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
3<br>
1 2 3<br>
0 2 6<br>
7 4 1<br>
2 7 0</td>
	<td valign='top'>
1 0 7 2<br>
2 2 4 7<br>
3 6 1 0</td>
  </tr>
  <tr>
    <td valign='top'>
9<br>
5<br>
-7 -1 0 -4 -9<br>
5 -1 2 2 9<br>
3 1 -8 -1 -7<br>
9 0 8 -8 -1<br>
2 4 5 2 8<br>
-7 10 0 -4 -8<br>
-3 10 -7 10 3<br>
1 6 -7 -5 9<br>
-1 9 9 1 9</td>
    <td valign='top'>
-7 5 3 9 2 -7 -3 1 -1<br>
-1 -1 1 0 4 10 10 6 9<br>
0 2 -8 8 5 0 -7 -7 9<br>
-4 2 -1 -8 2 -4 10 -5 1<br>
-9 9 -7 -1 8 -8 3 9 9</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Два велосипеда (binarysearch2.py)</b>
</summary>
<br>

Вася решил накопить на два одинаковых велосипеда - себе и сестре. У Васи есть копилка, в которую каждый день он может
добавлять деньги. В процессе накопления Вася не вынимает деньги из копилки. У вас есть информация о росте Васиных
накоплений - сколько у Васи в копелке было денег в каждый из дней.

Ваша задача - по заданной стоимости велосипеда определить первый день, в который Вася смог бы купить один велосипед, а также первый день, в который он бы мог купить два велосипеда.
Решение должно работать за O(log n).

#### Формат входных данных
В первой строке дано число дней n, по которым велись наблюдения за Васиными накоплениями. 1<=n<=1000000.
В следующей строке записаны n целых неотрицательных чисел. Числа идут в порядке неубывания. Каждое из чисел не превосходит 1000000.
В третьей строке записано целое положительное число s - стоимость велосипеда. Это число не превосходит 1000000.

#### Формат результата
Нужно вывести два числа - номера дней по условию задачи.
Если необходимой суммы в копилке не нашлось, нужно вернуть -1 вместо номера дня.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
6<br>
1 2 4 4 6 8<br>
3</td>
    <td valign='top'>3 5</td>
  </tr>
  <tr>
    <td valign='top'>
6<br>
1 2 4 4 4 4<br>
3</td>
    <td valign='top'>3 -1</td>
  </tr>
  <tr>
    <td valign='top'>
6<br>
1 2 4 4 4 4<br>
10</td>
    <td valign='top'>-1 -1</td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
1 10 10 10<br>
2</td>
    <td valign='top'>2 2</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Генератор скобок (bracketsgenerator.py)</b>
</summary>
<br>

Рита по поручению Тимофея наводит порядок в правильных скобочных последовательностях (ПСП), состоящих только из круглых скобок (). Для этого ей надо сгенерировать все ПСП длины 2n в алфавитном порядке - алфавит состоит из ( и ) и открывающаяся скобка идёт раньше закрывающей. Помогите Рите - напишите программу, которая по заданному n выведет все ПСП в нужном порядке.

Рассмотрим второй пример. Надо вывести ПСП из четырёх символов. Таких всего две:
1. (())
2. ()()

(()) идёт раньше ()(), так как первый символ у них одинаковый, а на второй позиции у первой ПСП стоит (, который идёт раньше ).

#### Формат входных данных
На вход функция принимает n - целое число от 0 до 10.

#### Формат результата
Функция должна напечатать все возможные скобочные последовательности заданной длины в алфавитном (лексикографическом) порядке.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>3</td>
    <td valign='top'>
((()))<br>
(()())<br>
(())()<br>
()(())<br>
()()()</td>
  </tr>
  <tr>
    <td valign='top'>2</td>
    <td valign='top'>
(())<br>
()()</td>
  </tr>
  <tr>
    <td valign='top'>4</td>
    <td valign='top'>
(((())))<br>
((()()))<br>
((())())<br>
((()))()<br>
(()(()))<br>
(()()())<br>
(()())()<br>
(())(())<br>
(())()()<br>
()((()))<br>
()(()())<br>
()(())()<br>
()()(())<br>
()()()()</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Комбинации (combinations_mobile.py)</b>
</summary>
<br>

На клавиатуре старых мобильных телефонов каждой цифре соответствовало несколько букв. Примерно так:
2: 'abc'
3: 'def'
4: 'ghi'
5: 'jkl'
6: 'mno'
7: 'pqrs'
8: 'tuv'
9: 'wxyz'

Вам известно в каком порядке были нажаты кнопки телефона, без учёта повторов. Напечатайте все комбинации букв, которые можно набрать такой последовательностью нажатий.

#### Формат входных данных
На вход подаётся строка, состоящая из цифр 2-9 включительно. Длина строки не превосходит 10 символов.

#### Формат результата
Выведите все возможные комбинации букв через пробел.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>23</td>
    <td valign='top'>ad ae af bd be bf cd ce cf</td>
  </tr>
  <tr>
    <td valign='top'>92</td>
    <td valign='top'>wa wb wc xa xb xc ya yb yc za zb zc</td>
  </tr>
  <tr>
    <td valign='top'>228</td>
    <td valign='top'>aat aau aav abt abu abv act acu acv bat bau bav bbt bbu bbv bct bcu bcv cat cau cav cbt cbu cbv cct ccu ccv</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Большое число (bignumber.py)</b>
</summary>
<br>

Вечером ребята решили поиграть в игру "Большое число".
Даны числа. Нужно определить, какое самое большое число можно из них составить.

#### Формат входных значений
В первой строке записано n - количество чисел. Оно не превосходит 100.
Во второй строке через пробел записаны n неотрицательных чисел, каждое из которых не превосходит 1000.

#### Формат результата
Нужно вывести самое большое число, которое можно составить из данных чисел.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
3<br>
15 56 2</td>
    <td valign='top'>56215</td>
  </tr>
  <tr>
    <td valign='top'>
3<br>
1 783 2</td>
    <td valign='top'>78321</td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
2 4 5 2 10</td>
    <td valign='top'>542210</td>
  </tr>
  <tr>
    <td valign='top'>
6<br>
9 10 1 1 1 6</td>
    <td valign='top'>9611110</td>
  </tr>
<tr>
    <td valign='top'>
38<br>
82 58 66 34 64 37 40 97 93 52 28 98 90 64 19 22 21 83 56 70 46 17 31 51 55 41 68 18 98 89 88 74 6 6 31 36 35 8</td>
    <td valign='top'>9898979390898888382747068666664645856555251464140373635343131282221191817</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Клумбы (segmentsunion.py)</b>
</summary>
<br>

Алла захотела, чтобы у неё под окном были узкие клумбы с тюльпанами. На схеме земельного участка клумбы обозначаются просто горизонтальными отрезками, лежащими на одной прямой. Для ландшафтных работы было нанято n садовников. Каждый из них обрабатывал какой-то отрезок на схеме. Процесс был организован не очень хорошо, иногда один и тот же отрезок или его часть могли быть обработаны сразу несколькими садовниками. Таким образом, отрезки, обрабатываемые двумя разными садовниками, сливаются в один. Непрерывный обработанный отрезок затем станет клумбой. Нужно определить границы будущих клумб.

#### Формат входных данных
В первой строке записано n - количество отрезков.
В следующих n строках через пробел записаны 2 неотрицательных числа.

#### Формат результата
Вывести границы будущих клумб.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
7 8<br>
7 8<br>
2 3<br>
6 10</td>
    <td valign='top'>
2 3<br>
6 10</td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
2 3<br>
5 6<br>
3 4<br>
3 4</td>
    <td valign='top'>
2 4<br>
5 6</td>
  </tr>
  <tr>
    <td valign='top'>
6<br>
1 3<br>
3 5<br>
4 6<br>
5 6<br>
2 4<br>
7 10</td>
    <td valign='top'>
1 6<br>
7 10</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Гардероб (wardrobe.py)</b>
</summary>
<br>

Рита решила оставить у себя одежду только трёх цветов: розового, жёлтого и малинового.
После того как вещи других расцветок были убраны, Рита захотела отсортировать свой новый гардероб по цветам. Сначала должны идти вещи розового цвета, потом - жёлтого, и в конце - малинового. Помогите Рите справиться с этой задачей.

#### Формат входных данных
В первой строке задано количество предметов в гардеробе: n - оно не превосходит 1000000. Во второй строке даётся массив, в котором указан цвет для каждого предмета. Розовый цвет обозначен 0, жёлтый - 1, малиновый - 2.

#### Формат результата
Нужно вывести в строку через пробел цвета предметов в правильном порядке.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
7<br>
0 2 1 2 0 0 1</td>
    <td valign='top'>0 0 0 1 1 2 2</td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
2 1 2 0 1</td>
    <td valign='top'>
0 1 1 2 2</td>
  </tr>
  <tr>
    <td valign='top'>
6<br>
2 1 1 2 0 2</td>
    <td valign='top'>0 1 1 2 2 2</td>
  </tr>
  <tr>
    <td valign='top'>
0</td>
    <td valign='top'></td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Подпоследовательность (issubsequence.py)</b>
</summary>
<br>

Даны 2 строки, нужно понять, является ли первая из них подпоследовательностью второй. Когда строки достаточно длинные, очень трудно получить ответ на этот вопрос, просто посмотрев на них. Помогите Гоше написать функцию, которая решает эту задачу.

#### Формат входных данных
В первой строке записана строка s.
Во второй - строка t.

Обе строки состоят из маленьких латинских букв, длины строк не превосходят 150000. Строки могут быть пустыми.

#### Формат результата
Выведите True, если s является подпоследовательностью t, иначе - False.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
abc<br>
ahbgdcu</td>
    <td valign='top'>True</td>
  </tr>
  <tr>
    <td valign='top'>
abcp<br>
ahpc</td>
    <td valign='top'>False</td>
  </tr>
  <tr>
    <td valign='top'>
abcd<br>
dkajsdlkbca</td>
    <td valign='top'>False</td>
  </tr>
  <tr>
    <td valign='top'>
<br>
anystring</td>
    <td valign='top'>True</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Пузырек (bubblesort.py)</b>
</summary>
<br>

Требуется реализовать алгоритм сортировки пузырьком (по неубыванию):
1. На каждой итерации проходим по массиву, поочередно сравниваем пары соседних элементов. Если элемент на позиции i больше элемента на позиции i+1, то меняем их местами. После первой итерации самый большой элемент всплывёт в конце массива.
2. Проходим по массиву, выполняя указанные действия до тех пор, пока на очередной итерации не окажется, что обмены больше не нужны, то есть массив уже отсортирован.
3. После не более, чем n-1 итераций выполнение алгоритма заканчивается, так как на каждой итерации хотя бы один элемент оказывается на правильной позиции.

#### Формат входных данных
В первой строке на вход подаётся натуральное число n - длина массива, 2<=n<=1000.
Во второй строке через пробел записано n целых чисел.
Каждое из чисел по модулю не превосходит 1000.

#### Формат результата
После каждого прохода по массиву, на котором какие-то элементы меняются местами, выводите его промежуточное состояние.
Таким образом, если сортировка завершена за k меняющих массив итераций, то надо вывести k строк по n чисел в каждой - элементы массива после каждой из итераций.
Если массив был изначально отсортирован, то просто выведите его.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
<tr>
    <td valign='top'>
2<br>
4 51</td>
    <td valign='top'>4 5</td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
1 1 1 1 1</td>
    <td valign='top'>1 1 1 1 1</td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
4 3 9 2 1</td>
    <td valign='top'>
3 4 2 1 9<br>
3 2 1 4 9<br>
2 1 3 4 9<br>
1 2 3 4 9</td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
12 8 9 10 11</td>
    <td valign='top'>8 9 10 11 12</td>
  </tr>
  <tr>
    <td valign='top'>
10<br>
87 123 23 9 71 2 11 23 -99 0</td>
    <td valign='top'>
87 23 9 71 2 11 23 -99 0 123<br>
23 9 71 2 11 23 -99 0 87 123<br>
9 23 2 11 23 -99 0 71 87 123<br>
9 2 11 23 -99 0 23 71 87 123<br>
2 9 11 -99 0 23 23 71 87 123<br>
2 9 -99 0 11 23 23 71 87 123<br>
2 -99 0 9 11 23 23 71 87 123<br>
-99 0 2 9 11 23 23 71 87 123</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Двумерные массивы (211012_matrices.pas)</b>
</summary>
<br>

Даны квадратные матрицы A, B, C размерности n. Вычислить матрицу D. E - единичная матрица. Для решения задачи применить процедуры: сложения, вычитания и умножения матриц. Исходные и получаемые матрицы должны отображаться на форме.

#### Формат входных данных
На первой строке вводится целое положительное число n.
На последующих 3n строках вводятся строки матриц A, B, C по n целых чисел в строке, разделённых пробелами.

#### Формат результата
Вывести результирующую матрицу D = A * A - B * C + E.

#### Пример
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
3<br>
1 2 3<br>
-2 0 7<br>
-8 -7 -6<br>
8 17 22<br>
-1 1 17<br>
2 0 0<br>
9 6 3<br>
-1 -2 -3<br>
4 2 0</td>
    <td valign='top'>
-169 -77 26<br>
-116 -78 -42<br>
36 14 -42</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Поиск в сломанном массиве (binarysearch_shifted_array.py)</b>
</summary>
<br>

Произошла ошибка при копировании из одной структуры данных в другую. Массив чисел хранился в кольцевом буфере и был отсортирован по возрастанию, в нём можно было найти элемент за логарифмическое время. Данные были скопированы из кольцевого буфера в обычный массив, в результате они стали циклически сдвинуты. Нужно обеспечить возможность находить элемент за логарифмическое время.

#### Формат входных данных
В первой строке вводится размер массива n. Во второй - искомое число. На третьей строке идут n целых чисел через пробел.
Длина массива не превосходит 10000. Элементы массива и число k не превосходят по значению 10000.

#### Формат результата
Вернуть индекс элемента, равного k, если такой есть в массиве (нумерация с нуля).
Если элемент не найден, вернуть -1.
Изменять массив нельзя.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
9<br>
5<br>
19 21 100 101 1 4 5 7 12</td>
    <td valign='top'>6</td>
  </tr>
  <tr>
    <td valign='top'>
2<br>
1<br>
5 1</td>
    <td valign='top'>1</td>
  </tr>
</tbody></table>
</details>

---

<details>
<summary>
<b>Матричные манипуляции (MatrixManipulation.cpp)</b>
</summary>
<br>

Реализовать программу для работы с квадратной матрицей. Программа должна содержать:
1. Структуру, описывающую матрицу.
2. Функцию для заполнения квадратной матрицы размерностью n*n возрастающей последовательностью от 1 до n*n целых чисел по заданной схеме.
	
На примере n=4:\
4 3 2 1\
5 10 11 12\
6 9 14 13\
7 8 15 16

n=5:\
5 4 3 2 1\
6 13 14 15 16\
7 12 19 18 17\
8 11 20 23 24\
9 10 21 22 25

3. Функцию для заполнения квадратной матрицы размерностью n*n целых чисел.
4. Функция вывода матрицы в файл (в виде матрицы).
5. Функция нахождения обратной матрицы.
6. Функция умножения матриц.
</details>


---

<details>
<summary>
<b>Парсер арифметических операций (arithmetic_operations_parser.c)</b>
</summary>
<br>

Мир наш исполнен войны - целая вечность сражений во имя Императора. Он никогда не прекращает и не отступается от бесконечной вражды, а значит - не должны и мы.

Второй год Похода Мучений. В отдалённой системе войска Императора столкнулись с планетой полной ужасающих человекоподобных зверей, представляющих собой серьёзную угрозу. После ожесточённых боёв связь с ударным отрядом чёрных тамплиеров во главе с братом Герхартом была потеряна, в связи с чем было приятно единственно верное решение в таких ситуациях - ЭКСТЕРМИНАТУС, то есть полное уничтожение всего живого на поверхности. Для запуска орбитальной бомбардировки требуются специальные коды запуска. Обычно они приходят на отдельный канал и с ними не возникает никаких проблем, но в этот раз в связи с оплошностью подчинённого несколько передач принимались по одному каналу и результаты перемешались. Ваша задача состоит в том, чтобы извлечь из полученной информации коды запуска орудий.


#### Формат входных данных
Передача состоит из заглавных и строчных латинских букв, цифр, а также 4 основных арифметических действий '+', '-', '*', '/'. Её длина не превосходит 2000 символов. Известно, что кодом является некоторая команда вида A op B, где A и B - целые неотрицательные числа, а op - одно из арифметических действий, результат которой является корректно вычислимым выражением модуль которого не превосходит 120000. При этом выражение "A op B" является подстрокой исходного сообшения. Гарантируется, что числа A,B и результат операции над ними не переполняют 32-х битные целые знаковые числа. 

#### Формат результата
Необходимо найти все такие команды и вывести их каждую с новой строки в виде A op B = res, где res - результат вычисления. Всё остальное считается мусором из других передач. Заметим, что для выражения A op1 B op2 C нужно вывести:
A op1 B = res1\
B op2 C = res2

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>100+200/9</td>
    <td valign='top'>
100 + 200 = 300<br>
200 / 9 = 22</td>
  </tr>
  <tr>
    <td valign='top'>rDU+9519+28006-+45350-80003-7034/14870/50385i-25266-39120*8557</td>
    <td valign='top'>
9519 + 28006 = 37525<br>
45350 - 80003 = -34653<br>
80003 - 7034 = 72969<br>
7034 / 14870 = 0<br>
14870 / 50385 = 0<br>
25266 - 39120 = -13854</td>
  </tr>
</tbody></table>
</details>


---

<details>
<summary>
<b>Работа со списком (list_manipulation.c)</b>
</summary>
<br>

#### Формат входных данных
Во входном файле input.txt записаны две строки, каждая из которых содержит последовательность из не более чем 10000 целых чисел. Обе последовательности заканчиваются числом -1 (и оно не входит в последовательность), остальные числа неотрицательны и не превосходят 10^9.

Указание: при решении данной задачи запрещается использовать массивы. Для хранения последовательности чисел используйте однонаправленный или двунаправленный список.

#### Формат результата
Требуется в файл output.txt вывести без изменения порядка все члены второй последовательности, кроме тех которые встречаются в первой последовательности.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
1 8 4 12 -1<br>
2 4 1 3 5 8 -1</td>
    <td valign='top'>2 3 5</td>
  </tr>
  <tr>
    <td valign='top'>
3 5 4 2 0 -1<br>
5 3 2 1 0 4 3 -1</td>
    <td valign='top'>1</td>
  </tr>
</tbody></table>
</details>

---

<details>
<summary>
<b>Вставка в двоичное дерево поиска (search_tree_insertion.c)</b>
</summary>
<br>

Структура <b>struct</b> tree (<b>int</b> x; <b>struct</b> tree *left, *right, *parent;); описывает двоичное дерево поиска. Напишите функцию <b>void</b> ins (<b>struct</b> tree *t, <b>int</b> x), вставляющую в дерево поиска t, заведомо содержащее ключ x, элемент с ключом, на единицу меньшим следующего по размеру за x ключа в дереве, либо с ключом x+1, если x - максимальный элемент дерева. Гарантируется, что ключ, который нужно вставлять, не содержится в дереве.
</details>

---

<details>
<summary>
<b>Dual linked list (dualLinkedListTemplate.cpp)</b>
</summary>
<br>

Develop a template of a container class, that represents an abstract data type of dual linked list.
This class should contain random access iterator and have the following interface:
| Name | Description |
|---|---|
| constructor 	|  						|
| destructor 	|  						|
| operator= 	|  						|
| **Iterators:**|						|
| begin		| return iterator to beginning 			|
| end 		| return iterator to end 			|
| rbegin 	| return reverse iterator to reverse beginning	|
| rend 		| return reverse iterator to reverse end	|
| **Capacity:**	|  						|
| empty         | test whether container is empty		|
| size          | return size					|
|**Element access:**|						|
| front         | access first element				|
| back          | access last element				|
| **Modifiers:**|						|
| assign        | assign new content to container		|
| push_front    | insert element at beginning			|
| pop_front     | delete first element				|
| push_back     | add element at the end			|
| pop_back      | delete last element				|
| insert        | insert element x at index idx			|
| erase         | erase element					|
| swap          | swap content					|
| resize        | change size					|
| clear         | clear						|
| **Operations:**|   						|
| reverse       |  reverse the order of elements		|

It is forbidden to use std::iterator.
Demonstrate work of the implemented methods in the main function.
</details>

---

<details>
<summary>
<b>Горнолыжный курорт (hills.cpp)</b>
</summary>
<br>

Сеть пунктов проката горнолыжного оборудования представляет собой корневое дерево, состоящее из n вершин, пронумерованных от 1 до n с корнем в вершине номер 1. В каждой вершине имеется пункт проката. Пункт, расположенный в i-й вершине, закупает оборудование по цене c_i рублей за комплект.

Пусть a_i - суммарное количество комплектов горнолыжного оборудования, которое будет закуплено во всех пунктах проката, находящихся в поддереве вершины номер i. Согласно маркетинговым исследованиям для каждого i эта величина должна находиться в диапазоне: l_i <= a_i <= r_i.

Необходимо определить, какое количество комплектов нужно закупить к началу сезона каждому из пунктов проката, чтобы для поддерева любой вершины сети общее количество комплектов находилось в указанном маркетологами диапазоне, а суммарная стоимость всех купленных комплектов была как можно меньше. Либо определить, что выполнить все условия маркетологов невозможно.

Напомним, что граф называется деревом, если он связный и не содержит циклов. Между любыми двумя вершинами в дереве существует ровно один простой путь. Корневым деревом называется дерево, в котором есть одна выделенная вершина - корень. Поддеревом вершины v называют множество всех вершин, для которых вершина v лежит на пути от соответствующей вершины до корня. Обратите внимание, что сама вершина v тоже входит в это множество. Родителем вершины v называется такая вершина p_v, что v и pv соединены ребром, и pv лежит на пути от v до корня.


#### Формат входных данных

Каждый тест состоит из нескольких наборов входных данных. В первой строке дано одно целое число t - количество наборов входных данных. Далее следует описание наборов входных данных.

В первой строке каждого набора входных данных дано одно целое число n (1 <= n <= 100000) - количество вершин в дереве.

Во второй строке даны n - 1 целых чисел p2, p3, ..., pn (1<= pi < i), обозначающих, что родителем вершины i является вершина pi.

В следующей строке даны n целых чисел c1, ..., cn (1 <= ci <= 10^9), где ci - цена закупки одного комплекта оборудования пунктом проката номер i.

В следующих n строках даны по два целых числа li и ri (0 <= li <= ri <= 10^9) - ограничения на общее количество комплектов горнолыжного оборудования в пунктах проката, находящихся в поддереве вершины номер i, к началу сезона.

Гарантируется, что сумма n по всем наборам входных данных не превышает 100000.


#### Формат результата

Для каждого набора данных выведите ответ в следующем формате.

Если невозможно выполнить все условия маркетологов, в единственной строке выведите -1.

Иначе, в первой строке выведите минимальное количество рублей, которое необходимо потратить на закупку горнолыжного оборудования всем пунктам сети суммарно. Во второй строке выведите n целых чисел bi, где bi равно количеству комплектов, которое необходимо закупить пункту проката номер i. Если существует несколько способов выполнить все условия маркетологов, потратив минимальное возможное количество рублей, вы можете вывести любой из них.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
2<br>
3<br>
1 1<br>
3 1 2<br>
5 7<br>
1 2<br>
2 4<br>
2<br>
1<br>
5 5<br>
0 1<br>
2 2</td>
    <td valign='top'>
8<br>
0 2 3<br>
-1</td>
  </tr>
  <tr>
      <td valign='top'>
1<br>
10<br>
1 2 1 1 4 2 1 2 5<br>
229935705 252294888 574618756 226876866 225916692 249797075 133791770 102539705 760471176 956697279<br>
125 237<br>
48 102<br>
13 27<br>
20 42<br>
29 58<br>
11 22<br>
21 41<br>
13 26<br>
7 15<br>
20 40</td>
    <td valign='top'>
45429982917<br>
0 0 13 9 9 11 30 26 7 20</td>
  </tr>
</tbody></table>
</details>

---


<details>
<summary>
<b>Сумма и определитель матрицы (matrixsum.java)</b>
</summary>
<br>

Реализовать консольное приложение, которое имеет примитивный текстовый интерфейс и меню, состоящее как минимум из четырех пунктов:
* Ввод исходных данных, как вручную,  так и сгенерированных случайным образом
* Выполнение алгоритма по заданию
* Вывод результата
* Завершение работы программы

В работе можно использовать только массивы! Результат не может быть выведен без обработки введённых данных.
Вывод результата не может быть осуществлен без выполнения алгоритма.
При вводе новых данных результаты выполнения алгоритма "сбрасываются".
Варианты заданий, где указан массив слов подразумевают, что разделителями для слов являются пробельные символы и знаки препинания.

#### Формат входных данных
Две квадратные матрицы одинакового размера, значение которого также вводит пользователь.

#### Формат результата
Сумма матриц и значение ее определителя.

</details>

---


<details>
<summary>
<b>Количество выходных в году (weekdays_a_year.c)</b>
</summary>
<br>

В некоторой стране действует Григорианский календарь.
В добавление к выходным дням субботы и воскресенья выходными объявляются 1, 2, 4, 8, 16, 32, 64, 128 и 256 день в году (1 января считается днем 1).
Если такой день уже приходится на выходной, он не переносится, то есть дополнительный выходной “сгорает”.

#### Формат входных данных
Целое число - год (от 1902 до 2037).

#### Формат результата
Целое число - количество выходных дней в этом году.

</details>


---


<details>
<summary>
<b>В десятичную систему счисления (anytodecimal.c)</b>
</summary>
<br>

В аргументах командной строки задаются 64-битные беззнаковые числа в 17-ричной системе счисления.
На стандартный поток вывода напечатайте эти числа в десятичной системе счисления, упорядоченные по невозрастанию.

Пример запуска программы:
./solution 1 2 3

Результат работы программы:\
3\
2\
1

</details>


---

<details>
<summary>
<b>Бинаризуй (BinarizeMe.cpp)</b>
</summary>
<br>

Дана строка.
Требуется заменить все целые положительные числа в ней на двоичные аналоги (перевести из десятичной в двоичную систему счисления).

#### Формат входных данных
На вход подается строка из не более 255 символов, среди которых могут быть и пробельные.
Гарантируется, что числа в строке не начинаются с 0.

#### Формат результата
Строка - результат преобразования.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>192873a kjhfd129380</td>
    <td valign='top'>101111000101101001a kjhfd11111100101100100</td>
  </tr>
  <tr>
      <td valign='top'>6a8g923mx</td>
    <td valign='top'>110a1000g1110011011mx</td>
  </tr>
</tbody></table>
</details>

</details>

---

<details>
<summary>
<b>Электронные часы (digitalwatch.cpp)</b>
</summary>
<br>

У вас есть сломанные электронные часы, у которых некоторые пиксели перестали работать или наоборот - работают всегда.
Требуется по ним определить и вывести текущее время или вывести ошибку в случае, если этого сделать нельзя.

#### Формат входных данных
На вход подаются 6 строк по 20 символов. Каждый прямоугольник 6х5 задает цифру циферблата.

#### Формат результата
Выведите время в формате hh:mm.
Если на изображении присутствуют лишние пиксели или неверный формат времени (больше 23:59), выведите ERROR.
Если время нельзя определить однозначно, выведите AMBIGUITY.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
<tt>..##..####.####..##.</tt><br>
<tt>.#..#....#.#....#..#</tt><br>
<tt>....#...#..###..#..#</tt><br>
<tt>...#.....#....#..###</tt><br>
<tt>..#......#.#..#....#</tt><br>
<tt>.####.###...##..###.</tt></td>
    <td valign='top'>23:59</td>
  </tr>
  <tr>
      <td valign='top'>
<tt>....#.#..#.####..###</tt><br>
<tt>...##.#..#.#....#...</tt><br>
<tt>..#.#.#..#.###..###.</tt><br>
<tt>....#.####....#.#..#</tt><br>
<tt>....#....#.#..#.#..#</tt><br>
<tt>....#....#..##...##.</tt></td>
    <td valign='top'>14:56</td>
  </tr>
  <tr>
      <td valign='top'>
<tt>..##..####.#..#..##.</tt><br>
<tt>.#..#....#.#..#.#..#</tt><br>
<tt>.#..#...#..#..#..##.</tt><br>
<tt>.#..#..#...####.#..#</tt><br>
<tt>.#..#..#......#.#..#</tt><br>
<tt>..##...#......#..##.</tt></td>
    <td valign='top'>07:48</td>
  </tr>
  <tr>
      <td valign='top'>
<tt>....#..##..###...##.</tt><br>
<tt>...##.#..#....#.#..#</tt><br>
<tt>..#......#...#......</tt><br>
<tt>........#.....#....#</tt><br>
<tt>....#..#......#....#</tt><br>
<tt>......####.#.....##.</tt></td>
    <td valign='top'>AMBIGUITY</td>
  </tr>
  <tr>
      <td valign='top'>
<tt>....#..##..###...##.</tt><br>
<tt>...##.#..#....#.#..#</tt><br>
<tt>..#......#...#....#.</tt><br>
<tt>........#.....#....#</tt><br>
<tt>....#..#......#....#</tt><br>
<tt>.................##.</tt></td>
    <td valign='top'>12:38</td>
  </tr>
  <tr>
      <td valign='top'>
<tt>#...................</tt><br>
<tt>....................</tt><br>
<tt>....................</tt><br>
<tt>....................</tt><br>
<tt>....................</tt><br>
<tt>....................</tt></td>
    <td valign='top'>ERROR</td>
  </tr>
  <tr>
      <td valign='top'>
<tt>...........#........</tt><br>
<tt>....................</tt><br>
<tt>..#.....#.........#.</tt><br>
<tt>...........#........</tt><br>
<tt>.................#..</tt><br>
<tt>......#.............</tt></td>
    <td valign='top'>13:47</td>
  </tr>
</tbody></table>
</details>


---

<details>
<summary>
<b>Стабильная сортировка (stable_quicksort.cpp)</b>
</summary>
<br>

Требуется реализовать стабильную сортировку для следующей задачи.
Выведите фамилии и имена абитуриентов, подавших документы на поступление в ВУЗ в порядке убывания их среднего балла по ЕГЭ.

Про каждого ученика известны их фамилии, имена и баллы ЕГЭ по следующим предметам:
информатика, математика и русский язык.

#### Формат входных данных
В первой строке идет число N (1<=N<=10^5) - количество абитуриентов, подавших документы.
Далее идет N строк - описания ученика в формате "surname name inf_points math_points rus_points", где "surname" - строки длины не более 40, "*_points" - баллы за экзамены (целые числа от нуля до ста включительно).

#### Формат результата
Необходимо вывести пары фамилия - имя по одной на строке, разделяя фамилию и имя одним пробелом. Выводить баллы не нужно. Если несколько учащихся имеют одинаковые средние баллы, то их нужно выводить в порядке, заданном во входных данных.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
2<br>
Markov Alexander 100 99 98<br>
Ivanov Ivan 99 98 98</td>
    <td valign='top'>
Markov Alexander<br>
Ivanov Ivan</td>
  </tr>
  <tr>
      <td valign='top'>
3<br>
Markov Alexander 75 90 90<br>
Sergey Petrov 100 50 100<br>
Petrov Petr 99 94 71</td>
    <td valign='top'>
Petrov Petr<br>
Markov Alexander<br>
Sergey Petrov</td>
  </tr>
  <tr>
      <td valign='top'>
6<br>
A A 90 90 90<br>
B B 90 90 90<br>
C C 90 90 90<br>
D D 90 90 90<br>
E E 90 90 90<br>
F F 90 90 90</td>
    <td valign='top'>
A A<br>
B B<br>
C C<br>
D D<br>
E E<br>
F F</td>
  </tr>
</tbody></table>
</details>

---

<details>
<summary>
<b>Гипершашки (hypershashki.cpp)</b>
</summary>
<br>

Андрей работает судьей на чемпионате по гипершашкам. В каждой игре в гепершашки участвует три игрока.
По ходу игры каждый из игроков набирает некоторое положительное целое число баллов.
Если после окончания игры первый игрок набрал a баллов, второй - b, третий c, то говорят, что игра закончилась со счетом a : b : c.
Андрей знает, что правила игры гипершашек устроены таким образом, что в результате игры баллы любых двух игроков различаются не более чем в k раз.
После матча Андрей показывает его результат, размещая три карточки с очками игроков на специальном табло. Для этого у него есть набор из n карточек, на которых написаны числа
x1, x2, ..., xn. Чтобы выяснить, насколько он готов к чемпионату, Андрей хочет понять, сколько различных вариантов счета он сможет показать на табло, используя имеющиеся карточки.
Требуется написать программу, которая по числу k и значениям чисел на карточках, которые имеются у Андрея, определяет количество различных вариантов счета, которые Андрей может показать на табло.

#### Формат входных данных
Первая строка содержит два целых числа: n и k (3 <= n <= 100000, 1 <= k <= 10^9).
Вторая строка содержит n целых чисел x1, x2, ..., xn (1 <= xi <= 10^9).

#### Формат результата
Одно целое число - искомое количество различных вариантов счета.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
3 1<br>
1 1 1</td>
    <td valign='top'>1</td>
  </tr>
  <tr>
      <td valign='top'>
6 6<br>
1 1 1 2 2 21</td>
    <td valign='top'>8</td>
  </tr>
  <tr>
      <td valign='top'>
6 3<br>
1 2 3 4 5 6</td>
    <td valign='top'>66</td>
  </tr>
  <tr>
      <td valign='top'>
3 1<br>
1 2 3</td>
    <td valign='top'>0</td>
  </tr>
  <tr>
      <td valign='top'>
5 2<br>
2 2 3 4 5</td>
    <td valign='top'>18</td>
  </tr>
</tbody></table>
</details>

---

<details>
<summary>
<b>Карточная игра (cardgame.cpp)</b>
</summary>
<br>

В игре в зожника карточная колода раздается поровну двум игрокам.
Далее они вскрывают по одной верхней карте, и тот, чья карта старше, забирает себе обе вскрытые карты, которые кладутся под низ его колоды.
Тот, кто остается без карт - проигрывает.
Для простоты будем считать, что все карты различны по номиналу, а также, что самая младшая карта побеждает самую старшую карту ("шестерка берет туза").
Игрок, который забирает себе карты, сначала кладет под низ своей колоды карту первого игрока, затем карту второго игрока (то есть карта второго игрока оказывается внизу колоды).

Напишите программу, которая моделирует игру в зожника и определяет, кто выигрывает.
В игре участвует 10 карт, имеющих значения от 0 до 9, большая карта побеждает меньшую, карта со значением 0 побеждает карту 9.

#### Формат входных данных
Две строки: первая строка содержит 5 чисел, разделенных пробелами - номера карт первого игрока, вторая строка - номера карт второго игрока.
Карты перечислены сверху вниз, то есть каждая строка начинается с той карты, которая будет открыта первой.

#### Формат результата
Программа должна определить, кто выигрывает при данной раздаче, и вывести слово "first" или "second", после чего вывести количество ходов, сделанных до выигрыша.
Если на протяжении 10^6 ходов игра не заканчивается, программа должна вывести слово "botva".

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
1 3 5 7 9<br>
2 4 6 8 0</td>
    <td valign='top'>second 5</td>
  </tr>
  <tr>
    <td valign='top'>
7 8 3 0 4<br>
6 2 9 1 5</td>
    <td valign='top'>botva</td>
  </tr>
  <tr>
    <td valign='top'>
9 8 7 1 2<br>
0 3 4 5 6</td>
    <td valign='top'>second 15</td>
  </tr>
</tbody></table>
</details>

---

<details>
<summary>
<b>Задачи на графы (TasksOnGraphs.ipynb)</b>
</summary>
<br>

22 небольшие задачи на ориентированные и неориентированные графы, написанные на python.
В том числе задачи на подсчет числа компонент связности, определение транзитивности, полноты и регулярности графов.

</details>

---

<details>
<summary>
<b>Процессы: текущее время (fork_currentdate.c)</b>
</summary>
<br>

Родитель создает сына, тот — внука, а тот — правнука.
Правнук передает в канал текущее время, полученное с помощью системного вызова time, в бинарном виде (тип time_t).

Отец, сын и внук считывают время из канала. Процесс-отец выводит на экран строку "Y:????", где ???? заменяются на текущий год, сын — "M:??", где ?? заменяются на текущий месяц в году (от 1 до 12), число всегда выводится с двумя знаками, внук — "D:??", где ?? заменяются на номер дня в месяце, всегда выводящееся с двумя знаками.

Внук должен вывести число первым, сын — вторым, а отец — третьим.
Записывать в канал разрешается только правнуку.

Пример вывода:\
D:11\
M:09\
Y:2001

</details>

---

<details>
<summary>
<b>Процессы: сумма чисел (fork_printsum.c)</b>
</summary>
<br>

Процесс-родитель создает процесса-сына, а тот в свою очеред процесса-внука.
Процесс-родитель и процесс-внук должны быть соединены анонимным каналом в направлении от родителя к внуку.
Процесс-родитель считывает 32-битные знаковые целые числа, подаваемые на стандартном потоке ввода в текстовом виде.
Последовательность заканчивается признаком конца файла.
Процесс-родитель передает считанные числа в канал в бинарном виде.
Процесс-внук считывает числа из канала и вычисляет их сумму.
После чтения всех чисел процесс-внук выводит на стандартный поток вывода их сумму и завершает работу.
Процесс-родитель должен дождаться завершения всех порожденных им процессов и завершиться сам с кодом завершения 0.

Input
1 2 3 4 5 6 7 8 9 10
Output
55

</details>

---

<details>
<summary>
<b>Максимальная куча на бинарном дереве (maxheap.cpp)</b>
</summary>
<br>
	
Требуется реализовать приоритетную очередь с помощью бинарной пирамиды, поддерживающую три операции: добавить элемент, извлечь максимальный элемент и удалить заданный элемент.
При просеивании нельзя совершать лишние перемещения (например, в случае равенства элементов).
Если при просеивании вниз, рассматриваемый элемент можно перемещать как влево вниз, так и вправо вниз, то следует выбрать лево.


#### Формат входных данных
В первой строке вводятся два числа - максимальный размер приоритетной очереди N и количество запросов M, (1 <= M,N <= 10^5).
Далее идут M строк, в каждой строке - по одному запросу. Первое число в запросе задает его тип, остальные числа (если есть) - параметры запроса.
Тип 1 - извлечь максимальный (без параметров).
Тип 2 - добавить данный элемент в очередь. Запрос имеет один параметр - число из отрезка [-10^9;10^9].
Тип 3 - удалить элемент по индексу (индексы нумеруются с единицы).

#### Формат результата
В ответ на запрос типа 1 следует вывести:
Если извлекать было нечего (очередь пуста), то -1.
Иначе - два числа, первое - индекс конечного положения элемента после его просеивания (если удален последний элемент и просеивать нечего, то вывести 0),
второе - значение извлеченного элемента.
В ответ на запрос типа 2 следует вывести: Если добавить нельзя (нет места, т.к. в очереди уже N элементов), то -1. Иначе - индекс добавленного элемента.
В ответ на запрос типа 3 следует вывести: Если элемента с таким индексом нет и удаление невозможно, то -1. Иначе - значение удаленного элемента.
После выполнения всех запросов требуется вывести пирамиду в её конечном состоянии.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
4 10<br>
1<br>
2 9<br>
2 4<br>
2 9<br>
2 9<br>
2 7<br>
1<br>
3 4<br>
2 1<br>
3 3</td>
    <td valign='top'>
-1<br>
1<br>
2<br>
3<br>
2<br>
-1<br>
2 9<br>
-1<br>
4<br>
9<br>
9 4 1</td>
  </tr>
  <tr>
    <td valign='top'>
5 5<br>
2 4<br>
2 5<br>
1<br>
1<br>
1</td>
    <td valign='top'>
1<br>
1<br>
1 5<br>
0 4<br>
-1</td>
  </tr>
  <tr>
    <td valign='top'>
10 30<br>
1<br>
2 -1<br>
1<br>
1<br>
2 0<br>
1<br>
2 0<br>
2 9<br>
2 -6<br>
1<br>
1<br>
1<br>
1<br>
2 6<br>
2 4<br>
2 -1<br>
2 -5<br>
2 3<br>
1<br>
2 -5<br>
1<br>
1<br>
2 7<br>
1<br>
2 -3<br>
2 6<br>
1<br>
1<br>
2 4<br>
2 0</td>
    <td valign='top'>
-1<br>
1<br>
0 -1<br>
-1<br>
1<br>
0 0<br>
1<br>
1<br>
3<br>
2 9<br>
1 0<br>
0 -6<br>
-1<br>
1<br>
2<br>
3<br>
4<br>
5<br>
2 6<br>
5<br>
2 4<br>
3 3<br>
1<br>
2 7<br>
2<br>
1<br>
2 6<br>
2 -1<br>
1<br>
2<br>
4 0 -5 -5 -3</td>
  </tr>
</tbody></table>
</details>

---

<details>
<summary>
<b>Количество способов из 1 в N (countWays1toN.py)</b>
</summary>
<br>

Имеется калькулятор, который выполняет следующие операции:
* умножить число X на 2
* умножить число X на 3
* прибавить к числу X единицу

Определите, какое наименьшее количество операций требуется, чтобы получить из числа 1 число N.

#### Формат входных данных
Во входном файле написано натуральное число N, не превосходящее 10^6.

#### Формат результата
В первой строке выходного файла выведите минимальное количество операций. Во второй строке выведите числа, последовательно получающиеся при выполнении операций. Первое из них должно быть равно 1, а последнее N. Если решений несколько, выведите любое.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>1</td>
    <td valign='top'>
0<br>
1</td>
  </tr>
  <tr>
    <td valign='top'>5</td>
    <td valign='top'>
3<br>
1 3 4 5</td>
  </tr>
</tbody></table>
</details>

---

<details>
<summary>
<b>Движение по полосам (dorogi.py)</b>
</summary>
<br>

При организации движения по сложным перекресткам, для того, чтобы траектории водителей, выполняющих различные маневры,
не пересекались, вводят ограничения на возможные маневры водителей, в зависимости от того, по какой полосе движения водитель подъехал к перекрестку.
Для этого используется знак "движение по полосам".
Рассмотрим дорогу, подходящую к перекрестку, на котором сходится m дорог.
Водитель, подъезжающий к перекрестку по этой дороге, потенциально может продолжить свое движение в m различных направлениях - обратно по дороге, по которой он приехал,
а также по одной из оставшихся m - 1 дорог. Пронумеруем возможные направления числами от 1 до m слева направо с точки зрения подъезжающего водителя.
Номер 1 получит разворот и возврат по дороге, по которой водитель подъезжал к перекрестку, номер 2 - поворот на самую левую из дорог, и т.д.

Пусть дорога содержит n полос для движения.
Пронумеруем полосы от 1 до n слева направо, самая левая полоса получит номер 1, следующая номер 2, и т.д.
Знак "движение по полосам" разрешает каждой из полос движение по некоторым из m возможных направлений.
При этом должны выполняться следующие условия:
1. Если с i-й полосы разрешено движение в a-м направлении, а с j-й полосы разрешено в b-м направлении, причём i < j, то a <= b.
2. С каждой полосы разрешено движение хотя бы в одном направлении.
3. В каждом направлении разрешено движение хотя бы с одной полосы.

Инспекция по безопасности дорожного движения заинтересовалась, а сколько различных знаков "движение по полосам" можно установить перед таким перекрестком.
Помогите им найти ответ на этот вопрос.

#### Формат входных данных
Два целых числа: m и n (2<=m<=50, 1<=n<=15).
m - число дорог, n - число полос

#### Формат результата
В выходной файл выведите одно число - количество возможных знаков "движение по полосам", которые можно установить перед перекрестком.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>4 2</td>
    <td valign='top'>7</td>
  </tr>
  <tr>
    <td valign='top'>5 2</td>
    <td valign='top'>9</td>
  </tr>
  <tr>
    <td valign='top'>4 3</td>
    <td valign='top'>25</td>
  </tr>
  <tr>
    <td valign='top'>50 15</td>
    <td valign='top'>108206580836328381</td>
  </tr>
</tbody></table>

#### Примечания
В первом примере возможны следующие варианты знаков "движение по полосам":

<table><tbody>
  <tr>
    <td><b>С левой полосы</b></td>
    <td><b>С правой полосы</b></td>
  </tr>
  <tr>
    <td valign='top'>разворот</td>
    <td valign='top'>разворот, налево, прямо, направо</td>
  </tr>
  <tr>
    <td valign='top'>разворот</td>
    <td valign='top'>налево, прямо, направо</td>
  </tr>
  <tr>
    <td valign='top'>разворот, налево</td>
    <td valign='top'>налево, прямо, направо</td>
  </tr>
  <tr>
    <td valign='top'>разворот, налево</td>
    <td valign='top'>прямо, направо</td>
  </tr>
  <tr>
    <td valign='top'>разворот, налево, прямо</td>
    <td valign='top'>прямо, направо</td>
  </tr>
  <tr>
    <td valign='top'>разворот, налево, прямо</td>
    <td valign='top'>направо</td>
  </tr>
  <tr>
    <td valign='top'>разворот, налево, прямо, направо</td>
    <td valign='top'>направо</td>
  </tr>
</tbody></table>
</details>

---

<details>
<summary>
<b>Каждому по компьютеру (pcforeverybody.py)</b>
</summary>
<br>

В каждом новом учебном году на занятия в компьютерные классы Дворца Творчества Юных пришли учащиеся, которые были разбиты на N групп. В i-й группе оказалось Xi человек. Тут же перед директором встала серьезная проблема: как распределить группы по аудиториям. Во дворце имеется M >= N аудиторий, в j-й аудитории имеется Yj компьютеров. Для занятий необходимо, чтобы у каждого учащегося был компьютер и еще один компьютер был у преподавателя. Переносить компьютеры из одной аудитории в другую запрещается. В одной аудитории одновременно может находиться только одна группа. Напишите программу, которая найдет, какое максимальное количество групп удастся одновременно распределить по аудиториям, чтобы всем учащимся в каждой группе хватило компьютеров, и при этом остался бы ещё хотя бы один для учителя.

#### Формат входных данных
На первой строке входного файла расположены числа N и M (1<=N<=M<=1000). На второй строке расположено N чисел - X1, X2, …, XN (1<=Xi<=1000). На третьей строке расположено M чисел Y1, …, YM (1<=Yi<=1000).

#### Формат результата
Выведите на первой строке число P - количество групп, которые удастся распределить по аудиториям. На второй строке выведите распределение групп по аудиториям - N чисел, i-е число должно соответствовать номеру аудитории, в которой должна заниматься i-я группа. (Нумерация как групп, так и аудиторий, начинается с 1). Если i-я группа осталась без аудитории, i-е число должно быть равно 0. Если допустимых распределений несколько, выведите любое из них.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
1 1<br>
1<br>
2</td>
    <td valign='top'>
1<br>
1</td>
  </tr>
  <tr>
    <td valign='top'>
1 1<br>
1<br>
1</td>
    <td valign='top'>
0<br>
0</td>
  </tr>
  <tr>
    <td valign='top'>
3 4<br>
5 3 4<br>
3 5 3 6</td>
    <td valign='top'>
2<br>
0 2 4</td>
  </tr>
  <tr>
    <td valign='top'>
3 3<br>
1 2 3<br>
3 4 2</td>
    <td valign='top'>
3<br>
3 1 2</td>
  </tr>
</tbody></table>
</details>


---

<details>
<summary>
<b>Турнир (tournament.py)</b>
</summary>
<br>

В турнире по хоккею участвовало K команд, каждая сыграла с каждой по одному матчу.
За победу команда получала 2 очка, за ничью - 1, за поражение - 0 очков.
Известно, сколько очков в итоге получила каждая команда, однако результаты конкретных матчей были утеряны. Требуется восстановить одну из возможных турнирных таблиц.

#### Формат входных данных
В первой строке входных данных содержится одно натуральное число K, не превосходящее 100 - количество команд. Во второй строке задаются через пробел K целых неотрицательных чисел, не превосходящих 2(K-1), количество очков, набранных командами, занявшими первое, второе, ..., K-е места соответственно (то есть каждое следующее число не больше предыдущего).

#### Формат результата
Выведите турнирную таблицу в следующем формате. Таблица должна состоять из K строк с результатами игр команд, занявших первое, второе, ..., последнее место (команды, набравшие одинаковое число очков, могут быть расположены в таблице в любом порядке). В каждой строке должно быть записано K чисел через пробел - количество очков, набранных в игре данной команды с первой, второй, ..., командами соответственно. Количество очков - это число 0, 1 или 2. В клетках на главной диагонали (соответствующих не существующей игре команды "самой с собой") нужно записать нули.
Гарантируется, что входные данные соответствуют реальному турниру, то есть хотя бы одна таблица, соответствующая входным данным, может быть построена. Если таких таблиц несколько, выведите любую из них.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
6 4 2 0</td>
    <td valign='top'>
0 2 2 2<br>
0 0 2 2<br>
0 0 0 2<br>
0 0 0 0</td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
3 3 3 3</td>
    <td valign='top'>
0 1 1 1<br>
1 0 1 1<br>
1 1 0 1<br>
1 1 1 0</td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
4 3 3 2</td>
    <td valign='top'>
0 1 1 2<br>
1 0 1 1<br>
1 1 0 1<br>
0 1 1 0</td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
6 5 5 2 2</td>
    <td valign='top'>
0 1 1 2 2<br>
1 0 1 1 2<br>
1 1 0 2 1<br>
0 1 0 0 1<br>
0 0 1 1 0</td>
  </tr>
</tbody></table>
</details>


---

<details>
<summary>
<b>Транспортировка (transfer.cpp)</b>
</summary>
<br>

К очередной Летней компьютерной школе было решено подготовить кружки как для школьников, так и для всех преподавателей.
 
Имея привычку делать важные дела в самый последний момент, дизайнер закончил работу над макетом за два дня до начала школы. Ещё день уйдёт у завода-изготовителя на то, чтобы изготовить кружки и нанести на них изображение. На то, чтобы довезти кружки от завода-изготовителя до ЛКШ, остаётся всего 24 часа.
 
Заказ на 10000000 экземпляров кружек (а именно столько заказали организаторы), конечно же, за один рейс не увезти. Однако, за первый рейс хочется привезти максимальное количество кружек. Для перевозки был заказан один большегрузный автомобиль. Но есть один нюанс: на некоторых дорогах установлено ограничение на вес автомобиля. Поэтому если автомобиль нагрузить кружками под завязку, то, возможно, не удастся воспользоваться самым коротким маршрутом, а придётся ехать в объезд. Может случиться даже так, что из-за этого грузовик не успеет доехать до лагеря вовремя, а этого допустить никак нельзя. Итак, сколько же кружек можно погрузить в автомобиль, чтобы успеть привезти этот ценный груз вовремя, и не нарушая правил дорожного движения
	
#### Формат входных данных
В первой строке находятся числа n (1≤n≤500) и m - количество узловых пунктов дорожной схемы и количество дорог, соответственно. В следующих m строках находится информация о дорогах. Каждая дорога описывается в отдельной строке следующим образом. Сначала указаны номера узловых пунктов, которые соединяются данной дорогой, потом время, которое тратится на проезд по этой дороге, и, наконец, максимальный вес автомобиля, которому разрешено ехать по этой дороге. Известно, что все дороги соединяют различные пункты, причем для каждой пары пунктов есть не более одной дороги, непосредственно их соединяющей. Все числа разделены одним или несколькими пробелами. 
 
Узловые пункты нумеруются числами от 1 до n. При этом завод по производству кружек имеет номер 1, а ЛКШ - номер n. Время проезда по дороге задано в минутах и не превосходит 1440 (24 часа). Ограничение на массу задано в граммах и не превосходит одного миллиарда. Кроме того, известно, что одна кружка весит 100 грамм, а пустой грузовик - 3 тонны.
 
#### Формат результата
Выведите одно число - максимальное количество кружек, которое можно привезти за первый рейс, потратив не более 24часов.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
3 3<br>
1 2 10 3000220<br>
2 3 20 3000201<br>
1 3 1 3000099</td>
    <td valign='top'>2</td>
  </tr>
</tbody></table>
</details>


---

<details>
<summary>
<b>Нормализация UNIX пути (unixpath.cpp)</b>
</summary>
<br>

В этой задаче нужно написать функцию, которая приводит к нормализованному виду строку, представляющую собой [путь к файлу или директории](https://www.geeksforgeeks.org/absolute-relative-pathnames-unix/) в UNIX-подобной операционной системе.

Нормализация пути заключается в приведении к абсолютному пути и избавлении от следующих элементов:
- `/` в конце пути
- `.` - текущая директория
- `..` - родительская директория
- `//` - равносильно `/`
	
#### Формат входных данных
На вход подается текущая директория `current_working_dir` (абсолютный путь, т.е. начинающийся с `/`) и путь `path`, который может быть как абсолютным, так и относительным. 
 
#### Формат результата
Надо вернуть нормализованный абсолютный путь, которому соответсвует `path`.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
NormalizePath("/", ".")</td>
    <td valign='top'>/</td>
  </tr>
  <tr>
    <td valign='top'>
NormalizePath("/home/user1", "../user2")</td>
    <td valign='top'>/home/user2</td>
  </tr>
  <tr>
    <td valign='top'>
NormalizePath("/", "..")</td>
    <td valign='top'>/</td>
  </tr>
  <tr>
    <td valign='top'>
NormalizePath("/home", "../../tmp")</td>
    <td valign='top'>/tmp</td>
  </tr>
  <tr>
    <td valign='top'>
NormalizePath("/", "../../a/")</td>
    <td valign='top'>/a</td>
  </tr>
  <tr>
    <td valign='top'>
NormalizePath("/", ".././/././/./../b/././././././")</td>
    <td valign='top'>/b</td>
  </tr>
</tbody></table>
</details>


---

<details>
<summary>
<b>Сапёр (minesweeper.cpp)</b>
</summary>
<br>

Реализуйте класс `Minesweeper` для игры "Сапёр".

## Структура класса

### Конструкторы
- принимающий размеры поля и количество мин - расставляет мины на поле случайным образом
- принимающий размеры поля и список клеток - расставляет мины на указанных клетках

### Методы
- `NewGame` - инициализирует новую игру; имеет два варианта, аналогичных конструкторам
- `OpenCell` - аналог клика левой кнопкой мыши
  - если игра выиграна или проиграна, ничего не делает  
  - если клетка с флажком, ничего не делает
  - если клетка без флажка, открывает клетку; алгоритм отрытия клеток описан ниже
- `MarkCell` - аналог клика правой кнопкой мыши
  - если игра выиграна или проиграна, ничего не делает 
  - пустую клетку отмечает флажком
  - с клетки с флажком снимает флажок
- `GetGameStatus` - возвращает статус игры
- `RenderField` - возвращает список строк, соответствующий отрисованному полю. Соответствие элементов символам:
  - закрытая клетка - `-`
  - клетка с миной - `*`
  - клетка с флагом - `?`
  - открытая клетка без мин - число от `1` до `8` (соответствует количеству мин в соседних клетках), вместо 0 рисуется `.`

## Алгоритм открытия клетки
- Если клетка содержит мину
  - открываются все клетки
  - игра заканчивается проигрышем
- Если клетка не содержит мину, но мина есть в соседней клетке, то открывается только эта клетка
- Если клетка и её соседи не содержат мин
  - текущая клетка открывается
  - алгоритм открытия клетки применяется ко всем соседям текущей клетки без флажка

Игра считается выигранной, когда открыты все клетки кроме тех, на которых стоят мины.

## Реализация

Внутреннее представление игры не должно быть завязано на отображение.
Преобразуйте внутреннее представление в строки только в методе `RenderField`.

Наивный алгоритм случайной расстановки мин может быть неэффективен при количестве мин, близком к общему количеству клеток.
Поле может быть очень большим. Не используйте рекурсивный вызов функций/методов для открытия клеток.

#### Примеры
Тесты для данной задачи находятся в функции main файла `minesweeper.cpp`.

</details>

---

<details>
<summary>
<b>К-я строка (kthstring.cpp)</b>
</summary>
<br>

Реализуйте структуру данных, которая поддерживает следующие операции:
* добавить в словарь строку S;
* найти в словаре k-ю строку в лексикографическом порядке.
Изначально словарь пуст.

#### Формат входных данных
Первая строка входного файла содержит число N — количество команд ($1≤N≤10^5$).
Последующие N строк содержат по одной команде каждая. Команды записываются следующим образом:
* 1 S — добавить строку S в словарь;
* 2 k — вывести k-ю строку в лексикографическом порядке.
Гарантируется, что при запросе 
k-й строки она существует. Также гарантируется, что сумма длин всех добавляемых строк не превышает $3*10^5$.
Все строки состоят из строчных латинских букв.

#### Формат результата
Для каждого запроса второго типа выведите k-ю в лексикографическом порядке строчку из словаря на момент запроса. Гарантируется, что суммарная длина строк в выходном файле не превышает $10^5$.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
7<br>
1 pushkin<br>
1 lermontov<br>
1 tolstoy<br>
1 gogol<br>
1 gorkiy<br>
2 5<br>
2 1</td>
    <td valign='top'>
tolstoy<br>
gogol</td>
  </tr>
</tbody></table>
</details>

---

<details>
<summary>
<b>Повторы подстрок в кольцевом списке (circulardups.c)</b>
</summary>
<br>

Вам дан тип узла двунаправленного закольцованного списка, который хранит Си-строку. Каждый элемент списка содержит адрес своей отдельной области памят под Си-строку.
struct list_item {
	char *str;
	struct list_item *prev, *next;
}
Напишите функцию void process(struct list_item **list, const char *s);

Она получает на вход указатель на начало двунаправленного закольцованного списка list и Си-строку s. Функция находит элементы списка, чья строка содержит строку s в качестве подстроки, и полностью дублирует этот элемент столько раз, какова длина этой строки. Остальные элементы надо переставить в конец списка с сохранением порядка. Функция должна один раз пройти по списку и не использовать функцию освобождения памяти.

Пример: если функция получит список ["a", "xabc", "ab"] и строку "abc", то список должен стать ["xabc", "xabc", "xabc", "xabc", "xabc", "a", "ab"].

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
a xabc ab<br>
abc</td>
    <td valign='top'>xabc xabc xabc xabc xabc a ab</td>
  </tr>
</tbody></table>
</details>

---

<details>
<summary>
<b>Последовательное выполнение команд с обработкой ошибок (concurrent_error.c)</b>
</summary>
<br>

Программа получает на стандартный ввод последовательность строк, каждая строка - это последовательность команд, разделенных точкой с запятой. За последней строкой может не идти перенос строки. Нужно выполнить последовательно все эти команды. Внутри команды точка с запятой не встречается. Команда состоит из последовательности слов - имени программы и ее аргументов. "Пустых" команд не может быть (т.е. в строке не может быть в конце и в начале точки запятой и двух точек с запятой подряд). Программу запускать с использованием переменной PATH. Код завершения программы равен коду завершения последней запущенной команды, если она завершилась системным вызовом _exit, а иначе 128 + номер сигнала. Если функция exec завершилась ошибкой, процесс завершается с кодом 127. В случае других ошибок - код завершения 1. Использовать bash напрямую или косвенно запрещается. Все аргументы разделены не менее чем одним пробельным символом. Длина строки ограничена лишь размерами памяти.

#### Примеры

<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
echo 1 ; echo 2<br>
echo 3 4a</td>
    <td valign='top'>
1<br>
2<br>
3 4a</td>
  </tr>
</tbody></table>
</details>

---

<details>
<summary>
<b>Выполнение команд сигналами и таймером (sigalarm_commands.c)</b>
</summary>
<br>

Аргументы командной строки вашей программы такие: p1 arg11 arg12 ... arg1N -- p2 arg21 arg22 ... arg2M. Отец создает дочерний процесс и соединяется с ним ровно одним каналом. Отец читает последовательность неотрицательных целых чисел со стандартного ввода. Если он читает 0, то отправляет сыну сигнал (выберите сами, какой), а если больше 0, он спит указанное количество микросекунд (функция usleep). Сын на каждый третий приход сигнала выполняет команду p1 arg11 arg12 ... arg1N | p2 arg21 arg22 ... arg2M, используя PATH. Первый пришедший сигнал имеет номер 1, т.е. первый раз сын должен запустить команду, получив сигнал в третий раз. Команды не должны пересекаться по времени. То есть их надо выполнять последовательно нужное количество раз. Активное ожидание недопустимо. Считать, что последовательность чисел не содержит двух нулей подряд и не оканчивается нулем. Отец завершает сына отправкой сигнала SIGTERM, сын должен довыполнить все требуемые команды и завершиться.

</details>

---

<details>
<summary>
<b>Параллельная запись и синхронизация процессов (concurrent_process_file.c)</b>
</summary>
<br>

Отец получает на стандартный ввод целые неотрицательные числа N и K. Отец создает временный файл и записывает туда число K. Затем он запускает параллельно N дочерних процессов. Дочерние процессы по очереди по кругу дописывают в конец файла число, на единицу меньшее, чем последнее число в файле. Как только они дошли до 0, дочерние процессы завершаются. Отец дожидается завершения дочерних процессов, распечатывает последовательно содержимое файла на стандартный вывод и удаляет файл. Глобальными переменными пользоваться нельзя. Синхронизацию процессов осуществить при помощи IPC. Число K детям иным образом, кроме как в файле, не передавать.


</details>

---

<details>

<summary>
<b>Рамка для рисунка (maximum_area.py)</b>
</summary>
<br>

У Алексея есть набор, который состоит из n палочек длины 1 и m палочек длины 2. Палочки можно соединять между собой, либо выстраивая их в линию, либо под прямым углом.
Алексей хочет собрать из имеющихся палочек рамку прямоугольной формы, чтобы потом вставить в эту рамку лист бумаги и нарисовать красивый пейзаж для мамы на Новый год.
При этом Алексей считает, что чем больше будет площадь прямоугольника, тем значимей будет его подарок. Поэтому ему важно определить максимальную площадь прямоугольника, границу которого можно собрать из имеющихся палочек.

#### Формат входных данных
Первая строка входных данных содержит целое число n — количество палочек длины 1, $0 <= n <= 10^9$.
Вторая строка входных данных содержит целое число m — количество палочек длины 2, $0 <= m <= 10^9$.

#### Формат результата
В единственной строке выведите единственное целое число — максимальную площадь прямоугольника, который можно сложить из имеющихся палочек. Если из имеющихся палочек невозможно сложить никакой прямоугольник, то выведите число 0.
Обратите внимание на то, что ответ в этой задаче может превышать возможное значение 32-битной целочисленной переменной, поэтому необходимо использовать 64-битные целочисленные типы данных (тип long long в языке C++, тип int64 в Pascal, тип long в Java и C#).

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
5<br>
0</td>
    <td valign='top'>1</td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
3</td>
    <td valign='top'>6</td>
  </tr>
  <tr>
    <td valign='top'>
3<br>
0</td>
    <td valign='top'>0</td>
  </tr>
</tbody></table>

#### Замечание
В первом примере есть 5 палочек длины 1. Из них можно сложить квадрат со стороной 1, его площадь равна 1, при этом одна палочка останется.
Во втором примере есть 4 палочки длины 1 и 3 палочки длины 2. Из них можно сложить прямоугольник размера 2 × 3.
В третьем примере есть 3 палочки длины 1, из них невозможно сложить прямоугольник.

</details>

---

<details>

<summary>
<b>Strcat (pointers_d2.c)</b>
</summary>
<br>

Реализовать функцию my_strcat конкатенации двух строк (аналог функции strcat).
Нельзя использовать операцию индексации (квадратные скобки) и ее эквивалентные выражения (т.е. требуется эффективная реализация).
Эта функция не должна знать, как получены строки (все ненулевые символы считаются значимыми!).

Для тестирования этой функции напишите функцию main.
Она считывает две строки (используйте функцию fgets).
Длина каждой строки не превосходит 80 символов.
Не забудьте заменить символ перевода строки на ноль!
Затем вызывается целевая функция так, чтобы в конец первой строки добавилась вторая строка.
В конце печатается строка-результат. Функция main завершается явным return 0.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
abc<br>
def</td>
    <td valign='top'>abcdef</td>
  </tr>
</tbody></table>
</details>

---

<details>

<summary>
<b>Проверка суффикса (pointers_d3.c)</b>
</summary>
<br>

Напишите функцию, которая получается два указателя - начало первой строки и начало второй строки - и возвращает единицу, если первая строка содержится в конце второй строки, и ноль в противном случае. Заголовок функции должен свидетельствовать, что функция не собирается менять содержимое обеих строк. Требуется эффективная реализация. Функция не должна знать, как созданы строки.

Напишите функцию main.
Она считывает две строки (используйте функцию fgets).
Длина каждой строки не превосходит 80 символов.
Не забудьте "занулить" символ перевода строки в них!
Затем вызывает целевую функцию и печатает строку YES, если результат истина, и NO иначе.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
abc<br>
de</td>
    <td valign='top'>NO</td>
  </tr>
  <tr>
    <td valign='top'>
abc<br>
defabc</td>
    <td valign='top'>YES</td>
  </tr>
</tbody></table>
</details>

---

<details>

<summary>
<b>Обмен знаками (pointers_d4.c)</b>
</summary>
<br>

Требуется написать программу, которая считывает два массива вещественных чисел (сначала идет целое число - размер массива - затем нужное количество вещественных чисел). Размеры массивов не превосходят 10000 (но даже такие массивы не нужно размещать на стеке!). Затем она меняет местами первый отрицательный элемент первого массива и последний положительный элемент второго массива, если оба эти числа существуют. В конце печатаются подряд числа первого массива, затем числа второго массива. Печатать каждое вещественное число нужно при помощи спецификатора %.llf. Требуется эффективная реализация. Не используйте глобальные переменные.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
  <tr>
    <td valign='top'>
2 -1.0 -2.0<br>
2 1.0 2.0</td>
    <td valign='top'>
2.0 -2.0<br>
1.0 -1.0</td>
  </tr>
</tbody></table>
</details>

---

<details>

<summary>
<b>Обмен знаками (pointers_d8.c)</b>
</summary>
<br>

Напишите функцию, которая получает на вход Си-строку и отыскивает в ней самое левое вхождение неотрицательного целого числа (непустой последовательности цифр). Функция возвращает успешность поиска, указатель на начало подстроки-числа и длину числа (подумайте, как составить заголовок этой функции!). Ведущих нулей в числе нет.

Для тестирования этой функции напишите функцию main. Она считывает одну строку (используйте функцию fgets). Длина строки не превосходит 80 символов. Затем при помощи написанной функции находит самое большое число и распечатывает его (подстрока с числом может быть очень длинная!).

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
<tr>
	<td valign='top'>123abc004</td>
	<td valign='top'>123</td>
</tr>
<tr>
    <td valign='top'>123abc124</td>
    <td valign='top'>124</td>
  </tr>
<tr>
    <td valign='top'>abc004</td>
    <td valign='top'>4</td>
</tr>
<tr>
    <td valign='top'>abc00</td>
    <td valign='top'>0</td>
</tr>
<tr>
    <td valign='top'>abc-32x</td>
    <td valign='top'>32</td>
</tr>
<tr>
    <td valign='top'>1111111111111111111111111111c</td>
    <td valign='top'>1111111111111111111111111111</td>
</tr>
</tbody></table>
</details>

---

<details>

<summary>
<b>Разворот (struct_heap_f3.c)</b>
</summary>
<br>

Напишите программу, которая читает последовательность целых чисел типа int до конца ввода (т.е. до первой ошибки в scanf).
Записывает числа последовательно в динамически расширяющийся массив.
Распечатывает последовательность в обратном порядке.

В динамически расширяющимся массиве количество операций реаллокации должно логарифмически зависеть от длины массива.

#### Примеры
<table><tbody>
  <tr>
    <td><b>Входные данные</b></td>
    <td><b>Результат работы</b></td>
  </tr>
<tr>
	<td valign='top'>-1 2 3</td>
	<td valign='top'>3 2 -1</td>
</tr>
</tbody></table>
</details>

---

<details>

<summary>
<b>Строковый switch (preproc_funcptrs_h3.c)</b>
</summary>
<br>

Реализуйте тип данных - строковый switch - отображение Си-строк в функции с одним формальным параметром - Си-строкой - и без возвращаемого значения. Оно указывает, какой код нужно выполнить для какой строки. Кроме этого, строковый switch должен иметь функцию с описанным выше заголовком для default-случая, т.е. если ни одна из строк не подошла. В имени типа данных не должно быть struct.

Напишите функцию выполнения строкового switch. Она получает его и Си-строку и выполняет соответствующий код. "Проваливания" нет. Указатель на функцию, равный NULL, означает пустой код.

Функция main для каждого аргумента командной строки (без имени программы) выполняет следующий строковый switch (используя функцию выше):
* на строку add печатается строка ADD
* на строку sub печатается строка SUB.
* Default-случай проверяет, является ли строка десятичной записью числа типа int (используя функцию strtol). В случае успеха печатает фразу NUMBER, иначе печатает строку UNKNOWN.

Эта задача без динамической памяти

</details>

---

<details>

<summary>
<b>Строковый switch 2 (preproc_funcptrs_h4.c)</b>
</summary>
<br>

Решите предыдущую задачу (preproc_funcptrs_h3.c) с другим строковым switch.
В нем должно быть отображение для строк add и sub.
default-случай ничего не делает.
На каждое нечетное (1-е, 3-е, 5-е, ... - счет идет с единицы) вхождение add должен печататься номер вхождения (1, 3, 5, ...). После 2-го sub надо завершить программу.

Тип строкового switch и функция выполнения его не меняются по сравнению с предыдущей задачей. Глобальные переменные и динамическую память не использовать.

</details>

---

<details>

<summary>
<b>Файловая синхронизация (processes_j4.c)</b>
</summary>
<br>

Два процесса работают одновременно. Каждый получил свой номер (1 или 2); напечатал строку с переданным ему номером и завершился. Организовать процессы так, чтобы всегда сначала печаталось 2, а потом 1. Исходный код процессов одинаковый, поместите его в отдельную функцию, принимающую число - номер для печати.

Создать процессы как дочерние в вашей программе. Использовать лишь известные нам средства (процессы и файлы).

Если потребуется создать файл, его нужно создавать в текущей директории и обязательно удалить.

Везде здесь и далее! Требования к программам на программирование процессов по умолчанию:
1. Обрабатывать ошибочные завершения системных вызовов не нужно;
2. Процесс, запускаемый первым, должен завершиться последним;
3. Процесс, запускаемый первым, должен завершиться с кодом 0;
4. Все файлы, передаваемые в программу, успешно открываются;
5. Все программы, которые надо запустить, успешно запускаются;
6. При запуске программ необходимо использовать переменную окружения PATH;
7. Активное ожидание недопустимо; переводите процессы в состояние сна до наступления некоторого события или на некоторое время (функция usleep).

</details>

---

<details>

<summary>
<b>Многозадачность: Отец и Сыновья (processes_j5.c)</b>
</summary>
<br>

Отец читает посимвольно стандартный ввод и для каждого символа, кроме первого, создает сына.
Сын получает от отца текущий символ и, если он совпадает с первым символом, печатает текущий символ дважды, иначе ничего не печатает.

Сыновья должны работать параллельно.
Размер ввода неограничен. Ввод непустой. Отец в конце печатает символ перевода строки, чтобы в итоге программа печатала ровно одну строку.

В начале программы отключите буферизацию ввода: setbuf(stdin, 0);

</details>

---

<details>

<summary>
<b>Изменение входного потока (input_change_k2.c)</b>
</summary>
<br>

Реализуйте команду шелла p < f, p (путь к программе) и f (путь к файлу) передаются в командной строке.

Функция main должна завершаться явным return.

Не использовать средства ввода-вывода стандартной библиотеки языки Си (stdio.h) для файлов.
В качестве исключения можно использовать scanf и printf для чисел.

</details>

---

<details>

<summary>
<b>Изменение выходного потока (output_change_k3.c)</b>
</summary>
<br>

Реализуйте команду шелла p > f, p (путь к программе) и f (путь к файлу) передаются в командной строке.

Функция main должна завершаться явным return.

При реализации перенаправления вывода файл создавать с правами rw-rw-rw-.

</details>

---

<details>

<summary>
<b>Композитные команды (shell_composite_k4.c)</b>
</summary>
<br>

Реализуйте команду шелла (p1 || p2) >> f && p3; p1, p2 (пути к программам), f (путь к файлу) и p3 (путь к программе) передаются в командной строке.

Функция main должна завершаться явным return.

Не ошибитесь в том, у какого из процессов (одного!) надо перенаправить вывод (круглые скобки означают создание дочернего процесса, внутри которого выполняется то, что идет внутри скобок).

</details>

---

<details>

<summary>
<b>Удаление второй строки (remove2nd_k5.c)</b>
</summary>
<br>

В командной строке находится имя текстового файла. Удалить из файла вторую строку, если она существует.

Функция main должна завершиться явным return.

Минимизировать количество вызываемых системных вызовов, т.е. чтение и запись не должны быть побайтовыми.

Имя временного файла создавать при помощи функции mkstemp в рабочей директории. Временный файл не должен существовать после завершения программы. Проще всего этого добиться, удалив его имя сразу после получения файлового дескриптора на него! При этом сам файл будет удален после закрытия всех файловых дескрипторов на него.

Совет! Решение этой задачи может быть понятнее при правильном разделении задачи на подзадачи.

</details>

---

<details>

<summary>
<b>Обработка сигналов (signal_m2.c)</b>
</summary>
<br>

Процесс-сын пишет номер каждого пришедшего сигнала SIGINT (строка с номером, начиная с 1) и завершается по 5-му приходу сигнала SIGINT. Процесс-отец создает сына, отправляет ему 5 раз сигнал SIGINT с интервалом в 50 микросекунд и дожидается его завершения.

Здесь и везде далее! Написание программ с сигналами сильно усложняется, если сигналы поступают извне слишком часто. Поэтому в учебных целях мы будем предполагать, что сигналы не поступают слишком часто извне. Но это не означает, что одиночный сигнал не может поступить в произвольный момент времени.

Функция main должна завершаться явным return.

</details>

---

<details>

<summary>
<b>Обработка сигналов 2 (signal_m3.c)</b>
</summary>
<br>

Программа читает со стандартного ввода число типа unsigned long long. Программа отнимает от него по 1. Завершается, как только дойдёт до 0. Каждые 5 секунд печатает строку с текущим числом (в самом начале программы печатать не надо). По сигналу SIGINT печатает строку с количеством секунд до следующей печати числа.

Функция main должна завершаться явным return.

</details>
