/*
Камера хранения

На железнодорожном вокзале столицы Бурляндии решили установить новую автоматическую камеру хранения.
Для этого потребовалось узнать, сколько ячеек одновременно занято хранящимся багажом.
Было установлено несколько датчиков использования старой камеры хранения, фиксировавших момент прихода пассажира и занятия им ячейки, а так же момент ухода пассажира и момент освобождения им ячейки.
Протокол прихода и ухода пассажиров за одни сутки приведён далее.
Ячейка не освобождается мгновенно, поэтому если в какое-то время один пассажир ушёл и в это же время пришёл другой пассажир, требуется две ячейки.
Определите максимальное количество одновременно занятых ячеек, наблюдаемое в течении суток.

Камера открыта круглосуточно. Времена прихода и ухода пассажиров находятся в пределах одних суток. В 00:00 камера хранения пуста.
Формат входных данных
N (количество пассажиров, 1<=N<=1000000).
HA1:MA1 HD1:MD1
...
HAN:MAN HDN:MDN

Формат результата
MaximumNumberOfBusyCells

Примеры
Входные данные
5
02:18 11:54
03:18 04:16
00:26 20:41
17:19 20:48
08:42 23:45

Результат работы
3


Входные данные
10
17:59 22:58
12:25 16:06
09:05 18:39
08:34 23:23
15:59 22:53
15:55 21:20
18:05 22:08
03:48 22:23
12:50 14:41
05:46 10:41

Результат работы
7

*/
#include <iostream>

unsigned int readTime() {
    char ch;
    while ((ch = getchar()) < '0' || ch > '9');
    unsigned int result = (ch - '0') * 10 * 60 + (getchar() - '0') * 60;
    getchar(); // :
    return result + (getchar() - '0') * 10 + getchar() - '0';
}


int main()
{
    int minutesOfADay[24*60+1];
    for (int i = 24 * 60; i >= 0; i--)
        minutesOfADay[i] = 0;

    unsigned int N;
    std::cin >> N;
    for (; N-- > 0;) {
        minutesOfADay[readTime()]++; // time of arrival
        minutesOfADay[readTime()+1]--; // time of departure
    }

    int maxLocks = 0;
    int currentLocks = 0;
    for (N = 0; N < 24 * 60; N++) {
        currentLocks += minutesOfADay[N];
        if (maxLocks < currentLocks) maxLocks = currentLocks;
    }

    std::cout << maxLocks << std::endl;

    return 0;
}