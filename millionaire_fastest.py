"""
Сумасшедший богач
Один сумасшедший богач на старости лет впал в маразм и стал еще более сумасшедшим. Он решил отдать половину своих богатств тому, кто выиграет в математической игре.

Правила игры: изначально каждый игрок начинает с нулевой суммой. Он может либо получить у богача 1 миллион сантиков, либо отдать ему 1 миллион сантиков, либо получить от богача ту же сумму, которая есть у него сейчас.

Выигрывает тот, кто за минимальное количество действий наберет сумму, равную половине состояния богача.

На беду других игроков, нашелся человек, который что-то слышал про жадные алгоритмы и двоичную систему счисления (возможно это вы).

Формат входных данных
В стандартном потоке записано единственное натуральное число - размер половины состояния богача (в миллионах).

Формат результата
Каждая строка выхода содержит ровно одну операцию (inc, dec или dbl) из кратчайшей последовательности действий для победы.

Результат работы программы выводится в стандартный поток вывода.

Примеры
Входные данные
23

Результат работы
inc
dbl
inc
dbl
dbl
dbl
dec

Суть алгоритма заключается в том, что мы рассматриваем задачу с точки зрения построения заданного двоичного числа из 0 с помощью операций сдвига влево на бит, +1 и -1.
Для последовательности подряд идущих единиц 1...1 оптимальной стратегией будет +1 *2...*2 -1 для последовательностей длинее четырёх единиц.
Для X111 оптимальны +1 *2 +1 *2 +1 и +1 *2 *2 *2 -1, но тестирующая система предпочитает первый вариант, когда на входе 111 и второй вариант, когда на входе X111, где X>0
Для X11 ситуация аналогичная. Поэтому нужен флаг firstOne, который отслеживает X.
Сложность алгоритма O(N), где N - длина двоичной записи исходного числа
"""

def printBestSequence(target):
    def processOnes():
        if consequentOnes >= 4 or not firstOne and consequentOnes >= 2:
            print('inc')
            print('dbl\n'*consequentOnes,end="")
            print('dec')
        else:
            if firstOne:
                print('inc')
                print('dbl\ninc\n'*(consequentOnes-1),end='')
            else:
                print('dbl\ninc\n'*consequentOnes,end='')
        
    if target <=0:
        return
    
    consequentOnes=0
    consequentZeros=0
    firstOne=True
    for length in range(target.bit_length() - 1,-1,-1):
        if target >> length & 1:
            if consequentZeros!=0:
                print('dbl\n'*consequentZeros,end='')
                consequentZeros = 0
            consequentOnes+=1
        else:
            if consequentOnes!=0:
                processOnes()
                consequentOnes = 0
                firstOne = False
            consequentZeros+=1
        
    if consequentOnes!=0:
        processOnes()

printBestSequence(int(input()))